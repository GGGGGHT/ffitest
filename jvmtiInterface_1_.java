// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct jvmtiInterface_1_ {
 *     void *reserved1;
 *     jvmtiError (*SetEventNotificationMode)(jvmtiEnv *, jvmtiEventMode, jvmtiEvent, jthread, ...);
 *     jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **);
 *     jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **);
 *     jvmtiError (*SuspendThread)(jvmtiEnv *, jthread);
 *     jvmtiError (*ResumeThread)(jvmtiEnv *, jthread);
 *     jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject);
 *     jvmtiError (*InterruptThread)(jvmtiEnv *, jthread);
 *     jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *);
 *     jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **);
 *     jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *);
 *     jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint);
 *     jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **);
 *     jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *);
 *     jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **);
 *     jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *);
 *     jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *);
 *     jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *);
 *     jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *);
 *     jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint);
 *     jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *);
 *     jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *);
 *     jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *);
 *     jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *);
 *     jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *);
 *     jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject);
 *     jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint);
 *     jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong);
 *     jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat);
 *     jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble);
 *     jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *);
 *     jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID);
 *     jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID);
 *     jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID);
 *     jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong);
 *     jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID);
 *     jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID);
 *     jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation);
 *     jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation);
 *     jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *);
 *     jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID);
 *     jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID);
 *     jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID);
 *     jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID);
 *     jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *);
 *     jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **);
 *     jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *);
 *     jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **);
 *     jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *);
 *     jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **);
 *     jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *);
 *     jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **);
 *     jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **);
 *     jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **);
 *     jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *);
 *     jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *);
 *     jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *);
 *     jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *);
 *     jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *);
 *     jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **);
 *     jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *);
 *     jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *);
 *     jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *);
 *     jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **);
 *     jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *);
 *     jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *);
 *     void *reserved67;
 *     jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *);
 *     jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *);
 *     jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **);
 *     jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *);
 *     jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **);
 *     jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *);
 *     jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **);
 *     jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **);
 *     jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *);
 *     jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *);
 *     jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **);
 *     jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **);
 *     jvmtiError (*PopFrame)(jvmtiEnv *, jthread);
 *     jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject);
 *     jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint);
 *     jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong);
 *     jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat);
 *     jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble);
 *     jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread);
 *     jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *);
 *     jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *);
 *     jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *);
 *     jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **);
 *     jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *);
 *     jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *);
 *     jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *);
 *     jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject);
 *     jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject);
 *     jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject);
 *     jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass);
 *     jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass);
 *     jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *);
 *     jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *);
 *     jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **);
 *     jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **);
 *     jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *);
 *     jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *);
 *     void *reserved105;
 *     jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *);
 *     jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong);
 *     jvmtiError (*ForceGarbageCollection)(jvmtiEnv *);
 *     jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *);
 *     jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *);
 *     jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *);
 *     jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *);
 *     void *reserved113;
 *     jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **);
 *     jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *);
 *     jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *);
 *     void *reserved117;
 *     jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *);
 *     jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *);
 *     jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *);
 *     jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **);
 *     jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint);
 *     jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent);
 *     jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **);
 *     jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **);
 *     jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent);
 *     jvmtiError (*DisposeEnvironment)(jvmtiEnv *);
 *     jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **);
 *     jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *);
 *     jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***);
 *     jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **);
 *     jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *);
 *     jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *);
 *     jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
 *     jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *);
 *     jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
 *     jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *);
 *     jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
 *     jvmtiError (*GetTime)(jvmtiEnv *, jlong *);
 *     jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *);
 *     void *reserved141;
 *     jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *);
 *     jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *);
 *     jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *);
 *     jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *);
 *     jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **);
 *     jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **);
 *     jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *);
 *     jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *);
 *     jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean);
 *     jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *);
 *     jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *);
 *     jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **);
 *     jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *);
 *     jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *);
 *     jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint);
 * }
 * }
 */
public class jvmtiInterface_1_ {

    jvmtiInterface_1_() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        jvmti_h.C_POINTER.withName("reserved1"),
        MemoryLayout.paddingLayout(8),
        jvmti_h.C_POINTER.withName("GetAllModules"),
        jvmti_h.C_POINTER.withName("GetAllThreads"),
        jvmti_h.C_POINTER.withName("SuspendThread"),
        jvmti_h.C_POINTER.withName("ResumeThread"),
        jvmti_h.C_POINTER.withName("StopThread"),
        jvmti_h.C_POINTER.withName("InterruptThread"),
        jvmti_h.C_POINTER.withName("GetThreadInfo"),
        jvmti_h.C_POINTER.withName("GetOwnedMonitorInfo"),
        jvmti_h.C_POINTER.withName("GetCurrentContendedMonitor"),
        jvmti_h.C_POINTER.withName("RunAgentThread"),
        jvmti_h.C_POINTER.withName("GetTopThreadGroups"),
        jvmti_h.C_POINTER.withName("GetThreadGroupInfo"),
        jvmti_h.C_POINTER.withName("GetThreadGroupChildren"),
        jvmti_h.C_POINTER.withName("GetFrameCount"),
        jvmti_h.C_POINTER.withName("GetThreadState"),
        jvmti_h.C_POINTER.withName("GetCurrentThread"),
        jvmti_h.C_POINTER.withName("GetFrameLocation"),
        jvmti_h.C_POINTER.withName("NotifyFramePop"),
        jvmti_h.C_POINTER.withName("GetLocalObject"),
        jvmti_h.C_POINTER.withName("GetLocalInt"),
        jvmti_h.C_POINTER.withName("GetLocalLong"),
        jvmti_h.C_POINTER.withName("GetLocalFloat"),
        jvmti_h.C_POINTER.withName("GetLocalDouble"),
        jvmti_h.C_POINTER.withName("SetLocalObject"),
        jvmti_h.C_POINTER.withName("SetLocalInt"),
        jvmti_h.C_POINTER.withName("SetLocalLong"),
        jvmti_h.C_POINTER.withName("SetLocalFloat"),
        jvmti_h.C_POINTER.withName("SetLocalDouble"),
        jvmti_h.C_POINTER.withName("CreateRawMonitor"),
        jvmti_h.C_POINTER.withName("DestroyRawMonitor"),
        jvmti_h.C_POINTER.withName("RawMonitorEnter"),
        jvmti_h.C_POINTER.withName("RawMonitorExit"),
        jvmti_h.C_POINTER.withName("RawMonitorWait"),
        jvmti_h.C_POINTER.withName("RawMonitorNotify"),
        jvmti_h.C_POINTER.withName("RawMonitorNotifyAll"),
        jvmti_h.C_POINTER.withName("SetBreakpoint"),
        jvmti_h.C_POINTER.withName("ClearBreakpoint"),
        jvmti_h.C_POINTER.withName("GetNamedModule"),
        jvmti_h.C_POINTER.withName("SetFieldAccessWatch"),
        jvmti_h.C_POINTER.withName("ClearFieldAccessWatch"),
        jvmti_h.C_POINTER.withName("SetFieldModificationWatch"),
        jvmti_h.C_POINTER.withName("ClearFieldModificationWatch"),
        jvmti_h.C_POINTER.withName("IsModifiableClass"),
        jvmti_h.C_POINTER.withName("Allocate"),
        jvmti_h.C_POINTER.withName("Deallocate"),
        jvmti_h.C_POINTER.withName("GetClassSignature"),
        jvmti_h.C_POINTER.withName("GetClassStatus"),
        jvmti_h.C_POINTER.withName("GetSourceFileName"),
        jvmti_h.C_POINTER.withName("GetClassModifiers"),
        jvmti_h.C_POINTER.withName("GetClassMethods"),
        jvmti_h.C_POINTER.withName("GetClassFields"),
        jvmti_h.C_POINTER.withName("GetImplementedInterfaces"),
        jvmti_h.C_POINTER.withName("IsInterface"),
        jvmti_h.C_POINTER.withName("IsArrayClass"),
        jvmti_h.C_POINTER.withName("GetClassLoader"),
        jvmti_h.C_POINTER.withName("GetObjectHashCode"),
        jvmti_h.C_POINTER.withName("GetObjectMonitorUsage"),
        jvmti_h.C_POINTER.withName("GetFieldName"),
        jvmti_h.C_POINTER.withName("GetFieldDeclaringClass"),
        jvmti_h.C_POINTER.withName("GetFieldModifiers"),
        jvmti_h.C_POINTER.withName("IsFieldSynthetic"),
        jvmti_h.C_POINTER.withName("GetMethodName"),
        jvmti_h.C_POINTER.withName("GetMethodDeclaringClass"),
        jvmti_h.C_POINTER.withName("GetMethodModifiers"),
        jvmti_h.C_POINTER.withName("reserved67"),
        jvmti_h.C_POINTER.withName("GetMaxLocals"),
        jvmti_h.C_POINTER.withName("GetArgumentsSize"),
        jvmti_h.C_POINTER.withName("GetLineNumberTable"),
        jvmti_h.C_POINTER.withName("GetMethodLocation"),
        jvmti_h.C_POINTER.withName("GetLocalVariableTable"),
        jvmti_h.C_POINTER.withName("SetNativeMethodPrefix"),
        jvmti_h.C_POINTER.withName("SetNativeMethodPrefixes"),
        jvmti_h.C_POINTER.withName("GetBytecodes"),
        jvmti_h.C_POINTER.withName("IsMethodNative"),
        jvmti_h.C_POINTER.withName("IsMethodSynthetic"),
        jvmti_h.C_POINTER.withName("GetLoadedClasses"),
        jvmti_h.C_POINTER.withName("GetClassLoaderClasses"),
        jvmti_h.C_POINTER.withName("PopFrame"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnObject"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnInt"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnLong"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnFloat"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnDouble"),
        jvmti_h.C_POINTER.withName("ForceEarlyReturnVoid"),
        jvmti_h.C_POINTER.withName("RedefineClasses"),
        jvmti_h.C_POINTER.withName("GetVersionNumber"),
        jvmti_h.C_POINTER.withName("GetCapabilities"),
        jvmti_h.C_POINTER.withName("GetSourceDebugExtension"),
        jvmti_h.C_POINTER.withName("IsMethodObsolete"),
        jvmti_h.C_POINTER.withName("SuspendThreadList"),
        jvmti_h.C_POINTER.withName("ResumeThreadList"),
        jvmti_h.C_POINTER.withName("AddModuleReads"),
        jvmti_h.C_POINTER.withName("AddModuleExports"),
        jvmti_h.C_POINTER.withName("AddModuleOpens"),
        jvmti_h.C_POINTER.withName("AddModuleUses"),
        jvmti_h.C_POINTER.withName("AddModuleProvides"),
        jvmti_h.C_POINTER.withName("IsModifiableModule"),
        jvmti_h.C_POINTER.withName("GetAllStackTraces"),
        jvmti_h.C_POINTER.withName("GetThreadListStackTraces"),
        jvmti_h.C_POINTER.withName("GetThreadLocalStorage"),
        jvmti_h.C_POINTER.withName("SetThreadLocalStorage"),
        jvmti_h.C_POINTER.withName("GetStackTrace"),
        jvmti_h.C_POINTER.withName("reserved105"),
        jvmti_h.C_POINTER.withName("GetTag"),
        jvmti_h.C_POINTER.withName("SetTag"),
        jvmti_h.C_POINTER.withName("ForceGarbageCollection"),
        jvmti_h.C_POINTER.withName("IterateOverObjectsReachableFromObject"),
        jvmti_h.C_POINTER.withName("IterateOverReachableObjects"),
        jvmti_h.C_POINTER.withName("IterateOverHeap"),
        jvmti_h.C_POINTER.withName("IterateOverInstancesOfClass"),
        jvmti_h.C_POINTER.withName("reserved113"),
        jvmti_h.C_POINTER.withName("GetObjectsWithTags"),
        jvmti_h.C_POINTER.withName("FollowReferences"),
        jvmti_h.C_POINTER.withName("IterateThroughHeap"),
        jvmti_h.C_POINTER.withName("reserved117"),
        jvmti_h.C_POINTER.withName("SuspendAllVirtualThreads"),
        jvmti_h.C_POINTER.withName("ResumeAllVirtualThreads"),
        jvmti_h.C_POINTER.withName("SetJNIFunctionTable"),
        jvmti_h.C_POINTER.withName("GetJNIFunctionTable"),
        jvmti_h.C_POINTER.withName("SetEventCallbacks"),
        jvmti_h.C_POINTER.withName("GenerateEvents"),
        jvmti_h.C_POINTER.withName("GetExtensionFunctions"),
        jvmti_h.C_POINTER.withName("GetExtensionEvents"),
        jvmti_h.C_POINTER.withName("SetExtensionEventCallback"),
        jvmti_h.C_POINTER.withName("DisposeEnvironment"),
        jvmti_h.C_POINTER.withName("GetErrorName"),
        jvmti_h.C_POINTER.withName("GetJLocationFormat"),
        jvmti_h.C_POINTER.withName("GetSystemProperties"),
        jvmti_h.C_POINTER.withName("GetSystemProperty"),
        jvmti_h.C_POINTER.withName("SetSystemProperty"),
        jvmti_h.C_POINTER.withName("GetPhase"),
        jvmti_h.C_POINTER.withName("GetCurrentThreadCpuTimerInfo"),
        jvmti_h.C_POINTER.withName("GetCurrentThreadCpuTime"),
        jvmti_h.C_POINTER.withName("GetThreadCpuTimerInfo"),
        jvmti_h.C_POINTER.withName("GetThreadCpuTime"),
        jvmti_h.C_POINTER.withName("GetTimerInfo"),
        jvmti_h.C_POINTER.withName("GetTime"),
        jvmti_h.C_POINTER.withName("GetPotentialCapabilities"),
        jvmti_h.C_POINTER.withName("reserved141"),
        jvmti_h.C_POINTER.withName("AddCapabilities"),
        jvmti_h.C_POINTER.withName("RelinquishCapabilities"),
        jvmti_h.C_POINTER.withName("GetAvailableProcessors"),
        jvmti_h.C_POINTER.withName("GetClassVersionNumbers"),
        jvmti_h.C_POINTER.withName("GetConstantPool"),
        jvmti_h.C_POINTER.withName("GetEnvironmentLocalStorage"),
        jvmti_h.C_POINTER.withName("SetEnvironmentLocalStorage"),
        jvmti_h.C_POINTER.withName("AddToBootstrapClassLoaderSearch"),
        jvmti_h.C_POINTER.withName("SetVerboseFlag"),
        jvmti_h.C_POINTER.withName("AddToSystemClassLoaderSearch"),
        jvmti_h.C_POINTER.withName("RetransformClasses"),
        jvmti_h.C_POINTER.withName("GetOwnedMonitorStackDepthInfo"),
        jvmti_h.C_POINTER.withName("GetObjectSize"),
        jvmti_h.C_POINTER.withName("GetLocalInstance"),
        jvmti_h.C_POINTER.withName("SetHeapSamplingInterval")
    ).withName("jvmtiInterface_1_");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout reserved1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static final AddressLayout reserved1$layout() {
        return reserved1$LAYOUT;
    }

    private static final long reserved1$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static final long reserved1$offset() {
        return reserved1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static MemorySegment reserved1(MemorySegment struct) {
        return struct.get(reserved1$LAYOUT, reserved1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static void reserved1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved1$LAYOUT, reserved1$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **)
     * }
     */
    public static class GetAllModules {

        GetAllModules() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetAllModules.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllModules.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllModules$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllModules"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **)
     * }
     */
    public static final AddressLayout GetAllModules$layout() {
        return GetAllModules$LAYOUT;
    }

    private static final long GetAllModules$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **)
     * }
     */
    public static final long GetAllModules$offset() {
        return GetAllModules$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **)
     * }
     */
    public static MemorySegment GetAllModules(MemorySegment struct) {
        return struct.get(GetAllModules$LAYOUT, GetAllModules$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **)
     * }
     */
    public static void GetAllModules(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllModules$LAYOUT, GetAllModules$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **)
     * }
     */
    public static class GetAllThreads {

        GetAllThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetAllThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **)
     * }
     */
    public static final AddressLayout GetAllThreads$layout() {
        return GetAllThreads$LAYOUT;
    }

    private static final long GetAllThreads$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **)
     * }
     */
    public static final long GetAllThreads$offset() {
        return GetAllThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **)
     * }
     */
    public static MemorySegment GetAllThreads(MemorySegment struct) {
        return struct.get(GetAllThreads$LAYOUT, GetAllThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **)
     * }
     */
    public static void GetAllThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllThreads$LAYOUT, GetAllThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SuspendThread)(jvmtiEnv *, jthread)
     * }
     */
    public static class SuspendThread {

        SuspendThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SuspendThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SuspendThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SuspendThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SuspendThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final AddressLayout SuspendThread$layout() {
        return SuspendThread$LAYOUT;
    }

    private static final long SuspendThread$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final long SuspendThread$offset() {
        return SuspendThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThread)(jvmtiEnv *, jthread)
     * }
     */
    public static MemorySegment SuspendThread(MemorySegment struct) {
        return struct.get(SuspendThread$LAYOUT, SuspendThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThread)(jvmtiEnv *, jthread)
     * }
     */
    public static void SuspendThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SuspendThread$LAYOUT, SuspendThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ResumeThread)(jvmtiEnv *, jthread)
     * }
     */
    public static class ResumeThread {

        ResumeThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ResumeThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ResumeThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ResumeThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ResumeThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final AddressLayout ResumeThread$layout() {
        return ResumeThread$LAYOUT;
    }

    private static final long ResumeThread$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final long ResumeThread$offset() {
        return ResumeThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThread)(jvmtiEnv *, jthread)
     * }
     */
    public static MemorySegment ResumeThread(MemorySegment struct) {
        return struct.get(ResumeThread$LAYOUT, ResumeThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThread)(jvmtiEnv *, jthread)
     * }
     */
    public static void ResumeThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ResumeThread$LAYOUT, ResumeThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static class StopThread {

        StopThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(StopThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(StopThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout StopThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("StopThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static final AddressLayout StopThread$layout() {
        return StopThread$LAYOUT;
    }

    private static final long StopThread$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static final long StopThread$offset() {
        return StopThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static MemorySegment StopThread(MemorySegment struct) {
        return struct.get(StopThread$LAYOUT, StopThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static void StopThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(StopThread$LAYOUT, StopThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*InterruptThread)(jvmtiEnv *, jthread)
     * }
     */
    public static class InterruptThread {

        InterruptThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(InterruptThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(InterruptThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout InterruptThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("InterruptThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*InterruptThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final AddressLayout InterruptThread$layout() {
        return InterruptThread$LAYOUT;
    }

    private static final long InterruptThread$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*InterruptThread)(jvmtiEnv *, jthread)
     * }
     */
    public static final long InterruptThread$offset() {
        return InterruptThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*InterruptThread)(jvmtiEnv *, jthread)
     * }
     */
    public static MemorySegment InterruptThread(MemorySegment struct) {
        return struct.get(InterruptThread$LAYOUT, InterruptThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*InterruptThread)(jvmtiEnv *, jthread)
     * }
     */
    public static void InterruptThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(InterruptThread$LAYOUT, InterruptThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *)
     * }
     */
    public static class GetThreadInfo {

        GetThreadInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *)
     * }
     */
    public static final AddressLayout GetThreadInfo$layout() {
        return GetThreadInfo$LAYOUT;
    }

    private static final long GetThreadInfo$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *)
     * }
     */
    public static final long GetThreadInfo$offset() {
        return GetThreadInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *)
     * }
     */
    public static MemorySegment GetThreadInfo(MemorySegment struct) {
        return struct.get(GetThreadInfo$LAYOUT, GetThreadInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *)
     * }
     */
    public static void GetThreadInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadInfo$LAYOUT, GetThreadInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **)
     * }
     */
    public static class GetOwnedMonitorInfo {

        GetOwnedMonitorInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetOwnedMonitorInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOwnedMonitorInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOwnedMonitorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOwnedMonitorInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **)
     * }
     */
    public static final AddressLayout GetOwnedMonitorInfo$layout() {
        return GetOwnedMonitorInfo$LAYOUT;
    }

    private static final long GetOwnedMonitorInfo$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **)
     * }
     */
    public static final long GetOwnedMonitorInfo$offset() {
        return GetOwnedMonitorInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **)
     * }
     */
    public static MemorySegment GetOwnedMonitorInfo(MemorySegment struct) {
        return struct.get(GetOwnedMonitorInfo$LAYOUT, GetOwnedMonitorInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **)
     * }
     */
    public static void GetOwnedMonitorInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOwnedMonitorInfo$LAYOUT, GetOwnedMonitorInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *)
     * }
     */
    public static class GetCurrentContendedMonitor {

        GetCurrentContendedMonitor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetCurrentContendedMonitor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentContendedMonitor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentContendedMonitor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentContendedMonitor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *)
     * }
     */
    public static final AddressLayout GetCurrentContendedMonitor$layout() {
        return GetCurrentContendedMonitor$LAYOUT;
    }

    private static final long GetCurrentContendedMonitor$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *)
     * }
     */
    public static final long GetCurrentContendedMonitor$offset() {
        return GetCurrentContendedMonitor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *)
     * }
     */
    public static MemorySegment GetCurrentContendedMonitor(MemorySegment struct) {
        return struct.get(GetCurrentContendedMonitor$LAYOUT, GetCurrentContendedMonitor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *)
     * }
     */
    public static void GetCurrentContendedMonitor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentContendedMonitor$LAYOUT, GetCurrentContendedMonitor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint)
     * }
     */
    public static class RunAgentThread {

        RunAgentThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RunAgentThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunAgentThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunAgentThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunAgentThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint)
     * }
     */
    public static final AddressLayout RunAgentThread$layout() {
        return RunAgentThread$LAYOUT;
    }

    private static final long RunAgentThread$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint)
     * }
     */
    public static final long RunAgentThread$offset() {
        return RunAgentThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint)
     * }
     */
    public static MemorySegment RunAgentThread(MemorySegment struct) {
        return struct.get(RunAgentThread$LAYOUT, RunAgentThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint)
     * }
     */
    public static void RunAgentThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunAgentThread$LAYOUT, RunAgentThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **)
     * }
     */
    public static class GetTopThreadGroups {

        GetTopThreadGroups() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetTopThreadGroups.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTopThreadGroups.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTopThreadGroups$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTopThreadGroups"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **)
     * }
     */
    public static final AddressLayout GetTopThreadGroups$layout() {
        return GetTopThreadGroups$LAYOUT;
    }

    private static final long GetTopThreadGroups$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **)
     * }
     */
    public static final long GetTopThreadGroups$offset() {
        return GetTopThreadGroups$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **)
     * }
     */
    public static MemorySegment GetTopThreadGroups(MemorySegment struct) {
        return struct.get(GetTopThreadGroups$LAYOUT, GetTopThreadGroups$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **)
     * }
     */
    public static void GetTopThreadGroups(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTopThreadGroups$LAYOUT, GetTopThreadGroups$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *)
     * }
     */
    public static class GetThreadGroupInfo {

        GetThreadGroupInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadGroupInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadGroupInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadGroupInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadGroupInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *)
     * }
     */
    public static final AddressLayout GetThreadGroupInfo$layout() {
        return GetThreadGroupInfo$LAYOUT;
    }

    private static final long GetThreadGroupInfo$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *)
     * }
     */
    public static final long GetThreadGroupInfo$offset() {
        return GetThreadGroupInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *)
     * }
     */
    public static MemorySegment GetThreadGroupInfo(MemorySegment struct) {
        return struct.get(GetThreadGroupInfo$LAYOUT, GetThreadGroupInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *)
     * }
     */
    public static void GetThreadGroupInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadGroupInfo$LAYOUT, GetThreadGroupInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **)
     * }
     */
    public static class GetThreadGroupChildren {

        GetThreadGroupChildren() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadGroupChildren.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadGroupChildren.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadGroupChildren$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadGroupChildren"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **)
     * }
     */
    public static final AddressLayout GetThreadGroupChildren$layout() {
        return GetThreadGroupChildren$LAYOUT;
    }

    private static final long GetThreadGroupChildren$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **)
     * }
     */
    public static final long GetThreadGroupChildren$offset() {
        return GetThreadGroupChildren$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **)
     * }
     */
    public static MemorySegment GetThreadGroupChildren(MemorySegment struct) {
        return struct.get(GetThreadGroupChildren$LAYOUT, GetThreadGroupChildren$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **)
     * }
     */
    public static void GetThreadGroupChildren(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadGroupChildren$LAYOUT, GetThreadGroupChildren$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static class GetFrameCount {

        GetFrameCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetFrameCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFrameCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFrameCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFrameCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static final AddressLayout GetFrameCount$layout() {
        return GetFrameCount$LAYOUT;
    }

    private static final long GetFrameCount$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static final long GetFrameCount$offset() {
        return GetFrameCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static MemorySegment GetFrameCount(MemorySegment struct) {
        return struct.get(GetFrameCount$LAYOUT, GetFrameCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static void GetFrameCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFrameCount$LAYOUT, GetFrameCount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static class GetThreadState {

        GetThreadState() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadState.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadState.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadState$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadState"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static final AddressLayout GetThreadState$layout() {
        return GetThreadState$LAYOUT;
    }

    private static final long GetThreadState$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static final long GetThreadState$offset() {
        return GetThreadState$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static MemorySegment GetThreadState(MemorySegment struct) {
        return struct.get(GetThreadState$LAYOUT, GetThreadState$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *)
     * }
     */
    public static void GetThreadState(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadState$LAYOUT, GetThreadState$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *)
     * }
     */
    public static class GetCurrentThread {

        GetCurrentThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetCurrentThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *)
     * }
     */
    public static final AddressLayout GetCurrentThread$layout() {
        return GetCurrentThread$LAYOUT;
    }

    private static final long GetCurrentThread$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *)
     * }
     */
    public static final long GetCurrentThread$offset() {
        return GetCurrentThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *)
     * }
     */
    public static MemorySegment GetCurrentThread(MemorySegment struct) {
        return struct.get(GetCurrentThread$LAYOUT, GetCurrentThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *)
     * }
     */
    public static void GetCurrentThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentThread$LAYOUT, GetCurrentThread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *)
     * }
     */
    public static class GetFrameLocation {

        GetFrameLocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetFrameLocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFrameLocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFrameLocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFrameLocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *)
     * }
     */
    public static final AddressLayout GetFrameLocation$layout() {
        return GetFrameLocation$LAYOUT;
    }

    private static final long GetFrameLocation$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *)
     * }
     */
    public static final long GetFrameLocation$offset() {
        return GetFrameLocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *)
     * }
     */
    public static MemorySegment GetFrameLocation(MemorySegment struct) {
        return struct.get(GetFrameLocation$LAYOUT, GetFrameLocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *)
     * }
     */
    public static void GetFrameLocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFrameLocation$LAYOUT, GetFrameLocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static class NotifyFramePop {

        NotifyFramePop() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(NotifyFramePop.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NotifyFramePop.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NotifyFramePop$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NotifyFramePop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static final AddressLayout NotifyFramePop$layout() {
        return NotifyFramePop$LAYOUT;
    }

    private static final long NotifyFramePop$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static final long NotifyFramePop$offset() {
        return NotifyFramePop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static MemorySegment NotifyFramePop(MemorySegment struct) {
        return struct.get(NotifyFramePop$LAYOUT, NotifyFramePop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static void NotifyFramePop(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NotifyFramePop$LAYOUT, NotifyFramePop$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *)
     * }
     */
    public static class GetLocalObject {

        GetLocalObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *)
     * }
     */
    public static final AddressLayout GetLocalObject$layout() {
        return GetLocalObject$LAYOUT;
    }

    private static final long GetLocalObject$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *)
     * }
     */
    public static final long GetLocalObject$offset() {
        return GetLocalObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *)
     * }
     */
    public static MemorySegment GetLocalObject(MemorySegment struct) {
        return struct.get(GetLocalObject$LAYOUT, GetLocalObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *)
     * }
     */
    public static void GetLocalObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalObject$LAYOUT, GetLocalObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *)
     * }
     */
    public static class GetLocalInt {

        GetLocalInt() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalInt.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalInt.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalInt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalInt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *)
     * }
     */
    public static final AddressLayout GetLocalInt$layout() {
        return GetLocalInt$LAYOUT;
    }

    private static final long GetLocalInt$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *)
     * }
     */
    public static final long GetLocalInt$offset() {
        return GetLocalInt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *)
     * }
     */
    public static MemorySegment GetLocalInt(MemorySegment struct) {
        return struct.get(GetLocalInt$LAYOUT, GetLocalInt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *)
     * }
     */
    public static void GetLocalInt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalInt$LAYOUT, GetLocalInt$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *)
     * }
     */
    public static class GetLocalLong {

        GetLocalLong() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalLong.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalLong.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalLong$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalLong"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *)
     * }
     */
    public static final AddressLayout GetLocalLong$layout() {
        return GetLocalLong$LAYOUT;
    }

    private static final long GetLocalLong$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *)
     * }
     */
    public static final long GetLocalLong$offset() {
        return GetLocalLong$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *)
     * }
     */
    public static MemorySegment GetLocalLong(MemorySegment struct) {
        return struct.get(GetLocalLong$LAYOUT, GetLocalLong$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *)
     * }
     */
    public static void GetLocalLong(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalLong$LAYOUT, GetLocalLong$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *)
     * }
     */
    public static class GetLocalFloat {

        GetLocalFloat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalFloat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalFloat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalFloat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalFloat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *)
     * }
     */
    public static final AddressLayout GetLocalFloat$layout() {
        return GetLocalFloat$LAYOUT;
    }

    private static final long GetLocalFloat$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *)
     * }
     */
    public static final long GetLocalFloat$offset() {
        return GetLocalFloat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *)
     * }
     */
    public static MemorySegment GetLocalFloat(MemorySegment struct) {
        return struct.get(GetLocalFloat$LAYOUT, GetLocalFloat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *)
     * }
     */
    public static void GetLocalFloat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalFloat$LAYOUT, GetLocalFloat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *)
     * }
     */
    public static class GetLocalDouble {

        GetLocalDouble() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalDouble.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalDouble.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalDouble$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalDouble"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *)
     * }
     */
    public static final AddressLayout GetLocalDouble$layout() {
        return GetLocalDouble$LAYOUT;
    }

    private static final long GetLocalDouble$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *)
     * }
     */
    public static final long GetLocalDouble$offset() {
        return GetLocalDouble$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *)
     * }
     */
    public static MemorySegment GetLocalDouble(MemorySegment struct) {
        return struct.get(GetLocalDouble$LAYOUT, GetLocalDouble$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *)
     * }
     */
    public static void GetLocalDouble(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalDouble$LAYOUT, GetLocalDouble$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject)
     * }
     */
    public static class SetLocalObject {

        SetLocalObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetLocalObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLocalObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLocalObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLocalObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject)
     * }
     */
    public static final AddressLayout SetLocalObject$layout() {
        return SetLocalObject$LAYOUT;
    }

    private static final long SetLocalObject$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject)
     * }
     */
    public static final long SetLocalObject$offset() {
        return SetLocalObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject)
     * }
     */
    public static MemorySegment SetLocalObject(MemorySegment struct) {
        return struct.get(SetLocalObject$LAYOUT, SetLocalObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject)
     * }
     */
    public static void SetLocalObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLocalObject$LAYOUT, SetLocalObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint)
     * }
     */
    public static class SetLocalInt {

        SetLocalInt() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetLocalInt.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLocalInt.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLocalInt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLocalInt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint)
     * }
     */
    public static final AddressLayout SetLocalInt$layout() {
        return SetLocalInt$LAYOUT;
    }

    private static final long SetLocalInt$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint)
     * }
     */
    public static final long SetLocalInt$offset() {
        return SetLocalInt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint)
     * }
     */
    public static MemorySegment SetLocalInt(MemorySegment struct) {
        return struct.get(SetLocalInt$LAYOUT, SetLocalInt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint)
     * }
     */
    public static void SetLocalInt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLocalInt$LAYOUT, SetLocalInt$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong)
     * }
     */
    public static class SetLocalLong {

        SetLocalLong() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetLocalLong.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLocalLong.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, long _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLocalLong$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLocalLong"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong)
     * }
     */
    public static final AddressLayout SetLocalLong$layout() {
        return SetLocalLong$LAYOUT;
    }

    private static final long SetLocalLong$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong)
     * }
     */
    public static final long SetLocalLong$offset() {
        return SetLocalLong$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong)
     * }
     */
    public static MemorySegment SetLocalLong(MemorySegment struct) {
        return struct.get(SetLocalLong$LAYOUT, SetLocalLong$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong)
     * }
     */
    public static void SetLocalLong(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLocalLong$LAYOUT, SetLocalLong$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat)
     * }
     */
    public static class SetLocalFloat {

        SetLocalFloat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, float _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetLocalFloat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLocalFloat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, float _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLocalFloat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLocalFloat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat)
     * }
     */
    public static final AddressLayout SetLocalFloat$layout() {
        return SetLocalFloat$LAYOUT;
    }

    private static final long SetLocalFloat$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat)
     * }
     */
    public static final long SetLocalFloat$offset() {
        return SetLocalFloat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat)
     * }
     */
    public static MemorySegment SetLocalFloat(MemorySegment struct) {
        return struct.get(SetLocalFloat$LAYOUT, SetLocalFloat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat)
     * }
     */
    public static void SetLocalFloat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLocalFloat$LAYOUT, SetLocalFloat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble)
     * }
     */
    public static class SetLocalDouble {

        SetLocalDouble() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, double _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_DOUBLE
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetLocalDouble.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLocalDouble.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, double _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLocalDouble$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLocalDouble"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble)
     * }
     */
    public static final AddressLayout SetLocalDouble$layout() {
        return SetLocalDouble$LAYOUT;
    }

    private static final long SetLocalDouble$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble)
     * }
     */
    public static final long SetLocalDouble$offset() {
        return SetLocalDouble$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble)
     * }
     */
    public static MemorySegment SetLocalDouble(MemorySegment struct) {
        return struct.get(SetLocalDouble$LAYOUT, SetLocalDouble$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble)
     * }
     */
    public static void SetLocalDouble(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLocalDouble$LAYOUT, SetLocalDouble$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *)
     * }
     */
    public static class CreateRawMonitor {

        CreateRawMonitor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(CreateRawMonitor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateRawMonitor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateRawMonitor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateRawMonitor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *)
     * }
     */
    public static final AddressLayout CreateRawMonitor$layout() {
        return CreateRawMonitor$LAYOUT;
    }

    private static final long CreateRawMonitor$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *)
     * }
     */
    public static final long CreateRawMonitor$offset() {
        return CreateRawMonitor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *)
     * }
     */
    public static MemorySegment CreateRawMonitor(MemorySegment struct) {
        return struct.get(CreateRawMonitor$LAYOUT, CreateRawMonitor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *)
     * }
     */
    public static void CreateRawMonitor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateRawMonitor$LAYOUT, CreateRawMonitor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static class DestroyRawMonitor {

        DestroyRawMonitor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(DestroyRawMonitor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DestroyRawMonitor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DestroyRawMonitor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DestroyRawMonitor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final AddressLayout DestroyRawMonitor$layout() {
        return DestroyRawMonitor$LAYOUT;
    }

    private static final long DestroyRawMonitor$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final long DestroyRawMonitor$offset() {
        return DestroyRawMonitor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static MemorySegment DestroyRawMonitor(MemorySegment struct) {
        return struct.get(DestroyRawMonitor$LAYOUT, DestroyRawMonitor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static void DestroyRawMonitor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DestroyRawMonitor$LAYOUT, DestroyRawMonitor$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static class RawMonitorEnter {

        RawMonitorEnter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RawMonitorEnter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RawMonitorEnter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RawMonitorEnter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RawMonitorEnter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final AddressLayout RawMonitorEnter$layout() {
        return RawMonitorEnter$LAYOUT;
    }

    private static final long RawMonitorEnter$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final long RawMonitorEnter$offset() {
        return RawMonitorEnter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static MemorySegment RawMonitorEnter(MemorySegment struct) {
        return struct.get(RawMonitorEnter$LAYOUT, RawMonitorEnter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static void RawMonitorEnter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RawMonitorEnter$LAYOUT, RawMonitorEnter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static class RawMonitorExit {

        RawMonitorExit() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RawMonitorExit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RawMonitorExit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RawMonitorExit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RawMonitorExit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final AddressLayout RawMonitorExit$layout() {
        return RawMonitorExit$LAYOUT;
    }

    private static final long RawMonitorExit$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final long RawMonitorExit$offset() {
        return RawMonitorExit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static MemorySegment RawMonitorExit(MemorySegment struct) {
        return struct.get(RawMonitorExit$LAYOUT, RawMonitorExit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static void RawMonitorExit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RawMonitorExit$LAYOUT, RawMonitorExit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong)
     * }
     */
    public static class RawMonitorWait {

        RawMonitorWait() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RawMonitorWait.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RawMonitorWait.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RawMonitorWait$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RawMonitorWait"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong)
     * }
     */
    public static final AddressLayout RawMonitorWait$layout() {
        return RawMonitorWait$LAYOUT;
    }

    private static final long RawMonitorWait$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong)
     * }
     */
    public static final long RawMonitorWait$offset() {
        return RawMonitorWait$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong)
     * }
     */
    public static MemorySegment RawMonitorWait(MemorySegment struct) {
        return struct.get(RawMonitorWait$LAYOUT, RawMonitorWait$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong)
     * }
     */
    public static void RawMonitorWait(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RawMonitorWait$LAYOUT, RawMonitorWait$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static class RawMonitorNotify {

        RawMonitorNotify() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RawMonitorNotify.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RawMonitorNotify.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RawMonitorNotify$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RawMonitorNotify"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final AddressLayout RawMonitorNotify$layout() {
        return RawMonitorNotify$LAYOUT;
    }

    private static final long RawMonitorNotify$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final long RawMonitorNotify$offset() {
        return RawMonitorNotify$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static MemorySegment RawMonitorNotify(MemorySegment struct) {
        return struct.get(RawMonitorNotify$LAYOUT, RawMonitorNotify$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static void RawMonitorNotify(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RawMonitorNotify$LAYOUT, RawMonitorNotify$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static class RawMonitorNotifyAll {

        RawMonitorNotifyAll() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RawMonitorNotifyAll.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RawMonitorNotifyAll.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RawMonitorNotifyAll$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RawMonitorNotifyAll"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final AddressLayout RawMonitorNotifyAll$layout() {
        return RawMonitorNotifyAll$LAYOUT;
    }

    private static final long RawMonitorNotifyAll$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static final long RawMonitorNotifyAll$offset() {
        return RawMonitorNotifyAll$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static MemorySegment RawMonitorNotifyAll(MemorySegment struct) {
        return struct.get(RawMonitorNotifyAll$LAYOUT, RawMonitorNotifyAll$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID)
     * }
     */
    public static void RawMonitorNotifyAll(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RawMonitorNotifyAll$LAYOUT, RawMonitorNotifyAll$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static class SetBreakpoint {

        SetBreakpoint() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetBreakpoint.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetBreakpoint.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetBreakpoint$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetBreakpoint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static final AddressLayout SetBreakpoint$layout() {
        return SetBreakpoint$LAYOUT;
    }

    private static final long SetBreakpoint$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static final long SetBreakpoint$offset() {
        return SetBreakpoint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static MemorySegment SetBreakpoint(MemorySegment struct) {
        return struct.get(SetBreakpoint$LAYOUT, SetBreakpoint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static void SetBreakpoint(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetBreakpoint$LAYOUT, SetBreakpoint$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static class ClearBreakpoint {

        ClearBreakpoint() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ClearBreakpoint.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearBreakpoint.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearBreakpoint$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearBreakpoint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static final AddressLayout ClearBreakpoint$layout() {
        return ClearBreakpoint$LAYOUT;
    }

    private static final long ClearBreakpoint$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static final long ClearBreakpoint$offset() {
        return ClearBreakpoint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static MemorySegment ClearBreakpoint(MemorySegment struct) {
        return struct.get(ClearBreakpoint$LAYOUT, ClearBreakpoint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation)
     * }
     */
    public static void ClearBreakpoint(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearBreakpoint$LAYOUT, ClearBreakpoint$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *)
     * }
     */
    public static class GetNamedModule {

        GetNamedModule() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetNamedModule.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetNamedModule.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetNamedModule$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetNamedModule"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *)
     * }
     */
    public static final AddressLayout GetNamedModule$layout() {
        return GetNamedModule$LAYOUT;
    }

    private static final long GetNamedModule$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *)
     * }
     */
    public static final long GetNamedModule$offset() {
        return GetNamedModule$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *)
     * }
     */
    public static MemorySegment GetNamedModule(MemorySegment struct) {
        return struct.get(GetNamedModule$LAYOUT, GetNamedModule$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *)
     * }
     */
    public static void GetNamedModule(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetNamedModule$LAYOUT, GetNamedModule$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static class SetFieldAccessWatch {

        SetFieldAccessWatch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetFieldAccessWatch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetFieldAccessWatch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetFieldAccessWatch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetFieldAccessWatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout SetFieldAccessWatch$layout() {
        return SetFieldAccessWatch$LAYOUT;
    }

    private static final long SetFieldAccessWatch$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final long SetFieldAccessWatch$offset() {
        return SetFieldAccessWatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment SetFieldAccessWatch(MemorySegment struct) {
        return struct.get(SetFieldAccessWatch$LAYOUT, SetFieldAccessWatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static void SetFieldAccessWatch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetFieldAccessWatch$LAYOUT, SetFieldAccessWatch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static class ClearFieldAccessWatch {

        ClearFieldAccessWatch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ClearFieldAccessWatch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearFieldAccessWatch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearFieldAccessWatch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearFieldAccessWatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout ClearFieldAccessWatch$layout() {
        return ClearFieldAccessWatch$LAYOUT;
    }

    private static final long ClearFieldAccessWatch$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final long ClearFieldAccessWatch$offset() {
        return ClearFieldAccessWatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment ClearFieldAccessWatch(MemorySegment struct) {
        return struct.get(ClearFieldAccessWatch$LAYOUT, ClearFieldAccessWatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static void ClearFieldAccessWatch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearFieldAccessWatch$LAYOUT, ClearFieldAccessWatch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static class SetFieldModificationWatch {

        SetFieldModificationWatch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetFieldModificationWatch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetFieldModificationWatch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetFieldModificationWatch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetFieldModificationWatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout SetFieldModificationWatch$layout() {
        return SetFieldModificationWatch$LAYOUT;
    }

    private static final long SetFieldModificationWatch$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final long SetFieldModificationWatch$offset() {
        return SetFieldModificationWatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment SetFieldModificationWatch(MemorySegment struct) {
        return struct.get(SetFieldModificationWatch$LAYOUT, SetFieldModificationWatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static void SetFieldModificationWatch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetFieldModificationWatch$LAYOUT, SetFieldModificationWatch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static class ClearFieldModificationWatch {

        ClearFieldModificationWatch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ClearFieldModificationWatch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearFieldModificationWatch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearFieldModificationWatch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearFieldModificationWatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout ClearFieldModificationWatch$layout() {
        return ClearFieldModificationWatch$LAYOUT;
    }

    private static final long ClearFieldModificationWatch$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static final long ClearFieldModificationWatch$offset() {
        return ClearFieldModificationWatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment ClearFieldModificationWatch(MemorySegment struct) {
        return struct.get(ClearFieldModificationWatch$LAYOUT, ClearFieldModificationWatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID)
     * }
     */
    public static void ClearFieldModificationWatch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearFieldModificationWatch$LAYOUT, ClearFieldModificationWatch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static class IsModifiableClass {

        IsModifiableClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsModifiableClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsModifiableClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsModifiableClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsModifiableClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final AddressLayout IsModifiableClass$layout() {
        return IsModifiableClass$LAYOUT;
    }

    private static final long IsModifiableClass$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final long IsModifiableClass$offset() {
        return IsModifiableClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static MemorySegment IsModifiableClass(MemorySegment struct) {
        return struct.get(IsModifiableClass$LAYOUT, IsModifiableClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static void IsModifiableClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsModifiableClass$LAYOUT, IsModifiableClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **)
     * }
     */
    public static class Allocate {

        Allocate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(Allocate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Allocate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Allocate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Allocate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **)
     * }
     */
    public static final AddressLayout Allocate$layout() {
        return Allocate$LAYOUT;
    }

    private static final long Allocate$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **)
     * }
     */
    public static final long Allocate$offset() {
        return Allocate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **)
     * }
     */
    public static MemorySegment Allocate(MemorySegment struct) {
        return struct.get(Allocate$LAYOUT, Allocate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **)
     * }
     */
    public static void Allocate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Allocate$LAYOUT, Allocate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *)
     * }
     */
    public static class Deallocate {

        Deallocate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(Deallocate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Deallocate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Deallocate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Deallocate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *)
     * }
     */
    public static final AddressLayout Deallocate$layout() {
        return Deallocate$LAYOUT;
    }

    private static final long Deallocate$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *)
     * }
     */
    public static final long Deallocate$offset() {
        return Deallocate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *)
     * }
     */
    public static MemorySegment Deallocate(MemorySegment struct) {
        return struct.get(Deallocate$LAYOUT, Deallocate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *)
     * }
     */
    public static void Deallocate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Deallocate$LAYOUT, Deallocate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **)
     * }
     */
    public static class GetClassSignature {

        GetClassSignature() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassSignature.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassSignature.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassSignature$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassSignature"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **)
     * }
     */
    public static final AddressLayout GetClassSignature$layout() {
        return GetClassSignature$LAYOUT;
    }

    private static final long GetClassSignature$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **)
     * }
     */
    public static final long GetClassSignature$offset() {
        return GetClassSignature$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **)
     * }
     */
    public static MemorySegment GetClassSignature(MemorySegment struct) {
        return struct.get(GetClassSignature$LAYOUT, GetClassSignature$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **)
     * }
     */
    public static void GetClassSignature(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassSignature$LAYOUT, GetClassSignature$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static class GetClassStatus {

        GetClassStatus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassStatus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassStatus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static final AddressLayout GetClassStatus$layout() {
        return GetClassStatus$LAYOUT;
    }

    private static final long GetClassStatus$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static final long GetClassStatus$offset() {
        return GetClassStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static MemorySegment GetClassStatus(MemorySegment struct) {
        return struct.get(GetClassStatus$LAYOUT, GetClassStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static void GetClassStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassStatus$LAYOUT, GetClassStatus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static class GetSourceFileName {

        GetSourceFileName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetSourceFileName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSourceFileName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSourceFileName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSourceFileName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static final AddressLayout GetSourceFileName$layout() {
        return GetSourceFileName$LAYOUT;
    }

    private static final long GetSourceFileName$OFFSET = 392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static final long GetSourceFileName$offset() {
        return GetSourceFileName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static MemorySegment GetSourceFileName(MemorySegment struct) {
        return struct.get(GetSourceFileName$LAYOUT, GetSourceFileName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static void GetSourceFileName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSourceFileName$LAYOUT, GetSourceFileName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static class GetClassModifiers {

        GetClassModifiers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassModifiers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassModifiers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassModifiers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassModifiers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static final AddressLayout GetClassModifiers$layout() {
        return GetClassModifiers$LAYOUT;
    }

    private static final long GetClassModifiers$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static final long GetClassModifiers$offset() {
        return GetClassModifiers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static MemorySegment GetClassModifiers(MemorySegment struct) {
        return struct.get(GetClassModifiers$LAYOUT, GetClassModifiers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *)
     * }
     */
    public static void GetClassModifiers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassModifiers$LAYOUT, GetClassModifiers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **)
     * }
     */
    public static class GetClassMethods {

        GetClassMethods() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassMethods.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassMethods.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassMethods$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassMethods"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **)
     * }
     */
    public static final AddressLayout GetClassMethods$layout() {
        return GetClassMethods$LAYOUT;
    }

    private static final long GetClassMethods$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **)
     * }
     */
    public static final long GetClassMethods$offset() {
        return GetClassMethods$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **)
     * }
     */
    public static MemorySegment GetClassMethods(MemorySegment struct) {
        return struct.get(GetClassMethods$LAYOUT, GetClassMethods$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **)
     * }
     */
    public static void GetClassMethods(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassMethods$LAYOUT, GetClassMethods$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **)
     * }
     */
    public static class GetClassFields {

        GetClassFields() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassFields.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassFields.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassFields$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassFields"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **)
     * }
     */
    public static final AddressLayout GetClassFields$layout() {
        return GetClassFields$LAYOUT;
    }

    private static final long GetClassFields$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **)
     * }
     */
    public static final long GetClassFields$offset() {
        return GetClassFields$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **)
     * }
     */
    public static MemorySegment GetClassFields(MemorySegment struct) {
        return struct.get(GetClassFields$LAYOUT, GetClassFields$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **)
     * }
     */
    public static void GetClassFields(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassFields$LAYOUT, GetClassFields$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **)
     * }
     */
    public static class GetImplementedInterfaces {

        GetImplementedInterfaces() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetImplementedInterfaces.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetImplementedInterfaces.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetImplementedInterfaces$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetImplementedInterfaces"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **)
     * }
     */
    public static final AddressLayout GetImplementedInterfaces$layout() {
        return GetImplementedInterfaces$LAYOUT;
    }

    private static final long GetImplementedInterfaces$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **)
     * }
     */
    public static final long GetImplementedInterfaces$offset() {
        return GetImplementedInterfaces$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **)
     * }
     */
    public static MemorySegment GetImplementedInterfaces(MemorySegment struct) {
        return struct.get(GetImplementedInterfaces$LAYOUT, GetImplementedInterfaces$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **)
     * }
     */
    public static void GetImplementedInterfaces(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetImplementedInterfaces$LAYOUT, GetImplementedInterfaces$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static class IsInterface {

        IsInterface() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsInterface.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsInterface.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsInterface$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsInterface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final AddressLayout IsInterface$layout() {
        return IsInterface$LAYOUT;
    }

    private static final long IsInterface$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final long IsInterface$offset() {
        return IsInterface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static MemorySegment IsInterface(MemorySegment struct) {
        return struct.get(IsInterface$LAYOUT, IsInterface$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static void IsInterface(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsInterface$LAYOUT, IsInterface$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static class IsArrayClass {

        IsArrayClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsArrayClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsArrayClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsArrayClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsArrayClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final AddressLayout IsArrayClass$layout() {
        return IsArrayClass$LAYOUT;
    }

    private static final long IsArrayClass$OFFSET = 440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static final long IsArrayClass$offset() {
        return IsArrayClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static MemorySegment IsArrayClass(MemorySegment struct) {
        return struct.get(IsArrayClass$LAYOUT, IsArrayClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *)
     * }
     */
    public static void IsArrayClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsArrayClass$LAYOUT, IsArrayClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *)
     * }
     */
    public static class GetClassLoader {

        GetClassLoader() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassLoader.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassLoader.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassLoader$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassLoader"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *)
     * }
     */
    public static final AddressLayout GetClassLoader$layout() {
        return GetClassLoader$LAYOUT;
    }

    private static final long GetClassLoader$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *)
     * }
     */
    public static final long GetClassLoader$offset() {
        return GetClassLoader$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *)
     * }
     */
    public static MemorySegment GetClassLoader(MemorySegment struct) {
        return struct.get(GetClassLoader$LAYOUT, GetClassLoader$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *)
     * }
     */
    public static void GetClassLoader(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassLoader$LAYOUT, GetClassLoader$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *)
     * }
     */
    public static class GetObjectHashCode {

        GetObjectHashCode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetObjectHashCode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectHashCode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectHashCode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectHashCode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *)
     * }
     */
    public static final AddressLayout GetObjectHashCode$layout() {
        return GetObjectHashCode$LAYOUT;
    }

    private static final long GetObjectHashCode$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *)
     * }
     */
    public static final long GetObjectHashCode$offset() {
        return GetObjectHashCode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *)
     * }
     */
    public static MemorySegment GetObjectHashCode(MemorySegment struct) {
        return struct.get(GetObjectHashCode$LAYOUT, GetObjectHashCode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *)
     * }
     */
    public static void GetObjectHashCode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectHashCode$LAYOUT, GetObjectHashCode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *)
     * }
     */
    public static class GetObjectMonitorUsage {

        GetObjectMonitorUsage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetObjectMonitorUsage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectMonitorUsage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectMonitorUsage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectMonitorUsage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *)
     * }
     */
    public static final AddressLayout GetObjectMonitorUsage$layout() {
        return GetObjectMonitorUsage$LAYOUT;
    }

    private static final long GetObjectMonitorUsage$OFFSET = 464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *)
     * }
     */
    public static final long GetObjectMonitorUsage$offset() {
        return GetObjectMonitorUsage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *)
     * }
     */
    public static MemorySegment GetObjectMonitorUsage(MemorySegment struct) {
        return struct.get(GetObjectMonitorUsage$LAYOUT, GetObjectMonitorUsage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *)
     * }
     */
    public static void GetObjectMonitorUsage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectMonitorUsage$LAYOUT, GetObjectMonitorUsage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **)
     * }
     */
    public static class GetFieldName {

        GetFieldName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetFieldName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFieldName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFieldName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFieldName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **)
     * }
     */
    public static final AddressLayout GetFieldName$layout() {
        return GetFieldName$LAYOUT;
    }

    private static final long GetFieldName$OFFSET = 472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **)
     * }
     */
    public static final long GetFieldName$offset() {
        return GetFieldName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **)
     * }
     */
    public static MemorySegment GetFieldName(MemorySegment struct) {
        return struct.get(GetFieldName$LAYOUT, GetFieldName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **)
     * }
     */
    public static void GetFieldName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFieldName$LAYOUT, GetFieldName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *)
     * }
     */
    public static class GetFieldDeclaringClass {

        GetFieldDeclaringClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetFieldDeclaringClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFieldDeclaringClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFieldDeclaringClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFieldDeclaringClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *)
     * }
     */
    public static final AddressLayout GetFieldDeclaringClass$layout() {
        return GetFieldDeclaringClass$LAYOUT;
    }

    private static final long GetFieldDeclaringClass$OFFSET = 480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *)
     * }
     */
    public static final long GetFieldDeclaringClass$offset() {
        return GetFieldDeclaringClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *)
     * }
     */
    public static MemorySegment GetFieldDeclaringClass(MemorySegment struct) {
        return struct.get(GetFieldDeclaringClass$LAYOUT, GetFieldDeclaringClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *)
     * }
     */
    public static void GetFieldDeclaringClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFieldDeclaringClass$LAYOUT, GetFieldDeclaringClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *)
     * }
     */
    public static class GetFieldModifiers {

        GetFieldModifiers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetFieldModifiers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFieldModifiers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFieldModifiers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFieldModifiers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *)
     * }
     */
    public static final AddressLayout GetFieldModifiers$layout() {
        return GetFieldModifiers$LAYOUT;
    }

    private static final long GetFieldModifiers$OFFSET = 488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *)
     * }
     */
    public static final long GetFieldModifiers$offset() {
        return GetFieldModifiers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *)
     * }
     */
    public static MemorySegment GetFieldModifiers(MemorySegment struct) {
        return struct.get(GetFieldModifiers$LAYOUT, GetFieldModifiers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *)
     * }
     */
    public static void GetFieldModifiers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFieldModifiers$LAYOUT, GetFieldModifiers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *)
     * }
     */
    public static class IsFieldSynthetic {

        IsFieldSynthetic() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsFieldSynthetic.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsFieldSynthetic.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsFieldSynthetic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsFieldSynthetic"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *)
     * }
     */
    public static final AddressLayout IsFieldSynthetic$layout() {
        return IsFieldSynthetic$LAYOUT;
    }

    private static final long IsFieldSynthetic$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *)
     * }
     */
    public static final long IsFieldSynthetic$offset() {
        return IsFieldSynthetic$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *)
     * }
     */
    public static MemorySegment IsFieldSynthetic(MemorySegment struct) {
        return struct.get(IsFieldSynthetic$LAYOUT, IsFieldSynthetic$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *)
     * }
     */
    public static void IsFieldSynthetic(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsFieldSynthetic$LAYOUT, IsFieldSynthetic$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **)
     * }
     */
    public static class GetMethodName {

        GetMethodName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetMethodName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMethodName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMethodName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMethodName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **)
     * }
     */
    public static final AddressLayout GetMethodName$layout() {
        return GetMethodName$LAYOUT;
    }

    private static final long GetMethodName$OFFSET = 504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **)
     * }
     */
    public static final long GetMethodName$offset() {
        return GetMethodName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **)
     * }
     */
    public static MemorySegment GetMethodName(MemorySegment struct) {
        return struct.get(GetMethodName$LAYOUT, GetMethodName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **)
     * }
     */
    public static void GetMethodName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMethodName$LAYOUT, GetMethodName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *)
     * }
     */
    public static class GetMethodDeclaringClass {

        GetMethodDeclaringClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetMethodDeclaringClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMethodDeclaringClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMethodDeclaringClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMethodDeclaringClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *)
     * }
     */
    public static final AddressLayout GetMethodDeclaringClass$layout() {
        return GetMethodDeclaringClass$LAYOUT;
    }

    private static final long GetMethodDeclaringClass$OFFSET = 512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *)
     * }
     */
    public static final long GetMethodDeclaringClass$offset() {
        return GetMethodDeclaringClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *)
     * }
     */
    public static MemorySegment GetMethodDeclaringClass(MemorySegment struct) {
        return struct.get(GetMethodDeclaringClass$LAYOUT, GetMethodDeclaringClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *)
     * }
     */
    public static void GetMethodDeclaringClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMethodDeclaringClass$LAYOUT, GetMethodDeclaringClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static class GetMethodModifiers {

        GetMethodModifiers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetMethodModifiers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMethodModifiers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMethodModifiers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMethodModifiers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final AddressLayout GetMethodModifiers$layout() {
        return GetMethodModifiers$LAYOUT;
    }

    private static final long GetMethodModifiers$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final long GetMethodModifiers$offset() {
        return GetMethodModifiers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static MemorySegment GetMethodModifiers(MemorySegment struct) {
        return struct.get(GetMethodModifiers$LAYOUT, GetMethodModifiers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static void GetMethodModifiers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMethodModifiers$LAYOUT, GetMethodModifiers$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved67$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved67"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved67
     * }
     */
    public static final AddressLayout reserved67$layout() {
        return reserved67$LAYOUT;
    }

    private static final long reserved67$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved67
     * }
     */
    public static final long reserved67$offset() {
        return reserved67$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved67
     * }
     */
    public static MemorySegment reserved67(MemorySegment struct) {
        return struct.get(reserved67$LAYOUT, reserved67$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved67
     * }
     */
    public static void reserved67(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved67$LAYOUT, reserved67$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static class GetMaxLocals {

        GetMaxLocals() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetMaxLocals.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMaxLocals.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMaxLocals$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMaxLocals"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final AddressLayout GetMaxLocals$layout() {
        return GetMaxLocals$LAYOUT;
    }

    private static final long GetMaxLocals$OFFSET = 536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final long GetMaxLocals$offset() {
        return GetMaxLocals$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static MemorySegment GetMaxLocals(MemorySegment struct) {
        return struct.get(GetMaxLocals$LAYOUT, GetMaxLocals$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static void GetMaxLocals(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMaxLocals$LAYOUT, GetMaxLocals$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static class GetArgumentsSize {

        GetArgumentsSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetArgumentsSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetArgumentsSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetArgumentsSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetArgumentsSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final AddressLayout GetArgumentsSize$layout() {
        return GetArgumentsSize$LAYOUT;
    }

    private static final long GetArgumentsSize$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static final long GetArgumentsSize$offset() {
        return GetArgumentsSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static MemorySegment GetArgumentsSize(MemorySegment struct) {
        return struct.get(GetArgumentsSize$LAYOUT, GetArgumentsSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *)
     * }
     */
    public static void GetArgumentsSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetArgumentsSize$LAYOUT, GetArgumentsSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **)
     * }
     */
    public static class GetLineNumberTable {

        GetLineNumberTable() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLineNumberTable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLineNumberTable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLineNumberTable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLineNumberTable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **)
     * }
     */
    public static final AddressLayout GetLineNumberTable$layout() {
        return GetLineNumberTable$LAYOUT;
    }

    private static final long GetLineNumberTable$OFFSET = 552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **)
     * }
     */
    public static final long GetLineNumberTable$offset() {
        return GetLineNumberTable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **)
     * }
     */
    public static MemorySegment GetLineNumberTable(MemorySegment struct) {
        return struct.get(GetLineNumberTable$LAYOUT, GetLineNumberTable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **)
     * }
     */
    public static void GetLineNumberTable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLineNumberTable$LAYOUT, GetLineNumberTable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *)
     * }
     */
    public static class GetMethodLocation {

        GetMethodLocation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetMethodLocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMethodLocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMethodLocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMethodLocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *)
     * }
     */
    public static final AddressLayout GetMethodLocation$layout() {
        return GetMethodLocation$LAYOUT;
    }

    private static final long GetMethodLocation$OFFSET = 560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *)
     * }
     */
    public static final long GetMethodLocation$offset() {
        return GetMethodLocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *)
     * }
     */
    public static MemorySegment GetMethodLocation(MemorySegment struct) {
        return struct.get(GetMethodLocation$LAYOUT, GetMethodLocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *)
     * }
     */
    public static void GetMethodLocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMethodLocation$LAYOUT, GetMethodLocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **)
     * }
     */
    public static class GetLocalVariableTable {

        GetLocalVariableTable() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalVariableTable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalVariableTable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalVariableTable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalVariableTable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **)
     * }
     */
    public static final AddressLayout GetLocalVariableTable$layout() {
        return GetLocalVariableTable$LAYOUT;
    }

    private static final long GetLocalVariableTable$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **)
     * }
     */
    public static final long GetLocalVariableTable$offset() {
        return GetLocalVariableTable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **)
     * }
     */
    public static MemorySegment GetLocalVariableTable(MemorySegment struct) {
        return struct.get(GetLocalVariableTable$LAYOUT, GetLocalVariableTable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **)
     * }
     */
    public static void GetLocalVariableTable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalVariableTable$LAYOUT, GetLocalVariableTable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *)
     * }
     */
    public static class SetNativeMethodPrefix {

        SetNativeMethodPrefix() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetNativeMethodPrefix.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetNativeMethodPrefix.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetNativeMethodPrefix$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetNativeMethodPrefix"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *)
     * }
     */
    public static final AddressLayout SetNativeMethodPrefix$layout() {
        return SetNativeMethodPrefix$LAYOUT;
    }

    private static final long SetNativeMethodPrefix$OFFSET = 576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *)
     * }
     */
    public static final long SetNativeMethodPrefix$offset() {
        return SetNativeMethodPrefix$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *)
     * }
     */
    public static MemorySegment SetNativeMethodPrefix(MemorySegment struct) {
        return struct.get(SetNativeMethodPrefix$LAYOUT, SetNativeMethodPrefix$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *)
     * }
     */
    public static void SetNativeMethodPrefix(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetNativeMethodPrefix$LAYOUT, SetNativeMethodPrefix$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **)
     * }
     */
    public static class SetNativeMethodPrefixes {

        SetNativeMethodPrefixes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetNativeMethodPrefixes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetNativeMethodPrefixes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetNativeMethodPrefixes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetNativeMethodPrefixes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **)
     * }
     */
    public static final AddressLayout SetNativeMethodPrefixes$layout() {
        return SetNativeMethodPrefixes$LAYOUT;
    }

    private static final long SetNativeMethodPrefixes$OFFSET = 584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **)
     * }
     */
    public static final long SetNativeMethodPrefixes$offset() {
        return SetNativeMethodPrefixes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **)
     * }
     */
    public static MemorySegment SetNativeMethodPrefixes(MemorySegment struct) {
        return struct.get(SetNativeMethodPrefixes$LAYOUT, SetNativeMethodPrefixes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **)
     * }
     */
    public static void SetNativeMethodPrefixes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetNativeMethodPrefixes$LAYOUT, SetNativeMethodPrefixes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **)
     * }
     */
    public static class GetBytecodes {

        GetBytecodes() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetBytecodes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBytecodes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBytecodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBytecodes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **)
     * }
     */
    public static final AddressLayout GetBytecodes$layout() {
        return GetBytecodes$LAYOUT;
    }

    private static final long GetBytecodes$OFFSET = 592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **)
     * }
     */
    public static final long GetBytecodes$offset() {
        return GetBytecodes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **)
     * }
     */
    public static MemorySegment GetBytecodes(MemorySegment struct) {
        return struct.get(GetBytecodes$LAYOUT, GetBytecodes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **)
     * }
     */
    public static void GetBytecodes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBytecodes$LAYOUT, GetBytecodes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static class IsMethodNative {

        IsMethodNative() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsMethodNative.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsMethodNative.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsMethodNative$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsMethodNative"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final AddressLayout IsMethodNative$layout() {
        return IsMethodNative$LAYOUT;
    }

    private static final long IsMethodNative$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final long IsMethodNative$offset() {
        return IsMethodNative$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static MemorySegment IsMethodNative(MemorySegment struct) {
        return struct.get(IsMethodNative$LAYOUT, IsMethodNative$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static void IsMethodNative(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsMethodNative$LAYOUT, IsMethodNative$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static class IsMethodSynthetic {

        IsMethodSynthetic() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsMethodSynthetic.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsMethodSynthetic.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsMethodSynthetic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsMethodSynthetic"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final AddressLayout IsMethodSynthetic$layout() {
        return IsMethodSynthetic$LAYOUT;
    }

    private static final long IsMethodSynthetic$OFFSET = 608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final long IsMethodSynthetic$offset() {
        return IsMethodSynthetic$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static MemorySegment IsMethodSynthetic(MemorySegment struct) {
        return struct.get(IsMethodSynthetic$LAYOUT, IsMethodSynthetic$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static void IsMethodSynthetic(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsMethodSynthetic$LAYOUT, IsMethodSynthetic$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **)
     * }
     */
    public static class GetLoadedClasses {

        GetLoadedClasses() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLoadedClasses.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLoadedClasses.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLoadedClasses$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLoadedClasses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **)
     * }
     */
    public static final AddressLayout GetLoadedClasses$layout() {
        return GetLoadedClasses$LAYOUT;
    }

    private static final long GetLoadedClasses$OFFSET = 616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **)
     * }
     */
    public static final long GetLoadedClasses$offset() {
        return GetLoadedClasses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **)
     * }
     */
    public static MemorySegment GetLoadedClasses(MemorySegment struct) {
        return struct.get(GetLoadedClasses$LAYOUT, GetLoadedClasses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **)
     * }
     */
    public static void GetLoadedClasses(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLoadedClasses$LAYOUT, GetLoadedClasses$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **)
     * }
     */
    public static class GetClassLoaderClasses {

        GetClassLoaderClasses() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassLoaderClasses.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassLoaderClasses.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassLoaderClasses$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassLoaderClasses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **)
     * }
     */
    public static final AddressLayout GetClassLoaderClasses$layout() {
        return GetClassLoaderClasses$LAYOUT;
    }

    private static final long GetClassLoaderClasses$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **)
     * }
     */
    public static final long GetClassLoaderClasses$offset() {
        return GetClassLoaderClasses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **)
     * }
     */
    public static MemorySegment GetClassLoaderClasses(MemorySegment struct) {
        return struct.get(GetClassLoaderClasses$LAYOUT, GetClassLoaderClasses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **)
     * }
     */
    public static void GetClassLoaderClasses(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassLoaderClasses$LAYOUT, GetClassLoaderClasses$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*PopFrame)(jvmtiEnv *, jthread)
     * }
     */
    public static class PopFrame {

        PopFrame() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(PopFrame.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(PopFrame.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout PopFrame$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("PopFrame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*PopFrame)(jvmtiEnv *, jthread)
     * }
     */
    public static final AddressLayout PopFrame$layout() {
        return PopFrame$LAYOUT;
    }

    private static final long PopFrame$OFFSET = 632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*PopFrame)(jvmtiEnv *, jthread)
     * }
     */
    public static final long PopFrame$offset() {
        return PopFrame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*PopFrame)(jvmtiEnv *, jthread)
     * }
     */
    public static MemorySegment PopFrame(MemorySegment struct) {
        return struct.get(PopFrame$LAYOUT, PopFrame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*PopFrame)(jvmtiEnv *, jthread)
     * }
     */
    public static void PopFrame(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(PopFrame$LAYOUT, PopFrame$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static class ForceEarlyReturnObject {

        ForceEarlyReturnObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static final AddressLayout ForceEarlyReturnObject$layout() {
        return ForceEarlyReturnObject$LAYOUT;
    }

    private static final long ForceEarlyReturnObject$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static final long ForceEarlyReturnObject$offset() {
        return ForceEarlyReturnObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static MemorySegment ForceEarlyReturnObject(MemorySegment struct) {
        return struct.get(ForceEarlyReturnObject$LAYOUT, ForceEarlyReturnObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject)
     * }
     */
    public static void ForceEarlyReturnObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnObject$LAYOUT, ForceEarlyReturnObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static class ForceEarlyReturnInt {

        ForceEarlyReturnInt() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnInt.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnInt.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnInt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnInt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static final AddressLayout ForceEarlyReturnInt$layout() {
        return ForceEarlyReturnInt$LAYOUT;
    }

    private static final long ForceEarlyReturnInt$OFFSET = 648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static final long ForceEarlyReturnInt$offset() {
        return ForceEarlyReturnInt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static MemorySegment ForceEarlyReturnInt(MemorySegment struct) {
        return struct.get(ForceEarlyReturnInt$LAYOUT, ForceEarlyReturnInt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint)
     * }
     */
    public static void ForceEarlyReturnInt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnInt$LAYOUT, ForceEarlyReturnInt$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong)
     * }
     */
    public static class ForceEarlyReturnLong {

        ForceEarlyReturnLong() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnLong.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnLong.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnLong$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnLong"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong)
     * }
     */
    public static final AddressLayout ForceEarlyReturnLong$layout() {
        return ForceEarlyReturnLong$LAYOUT;
    }

    private static final long ForceEarlyReturnLong$OFFSET = 656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong)
     * }
     */
    public static final long ForceEarlyReturnLong$offset() {
        return ForceEarlyReturnLong$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong)
     * }
     */
    public static MemorySegment ForceEarlyReturnLong(MemorySegment struct) {
        return struct.get(ForceEarlyReturnLong$LAYOUT, ForceEarlyReturnLong$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong)
     * }
     */
    public static void ForceEarlyReturnLong(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnLong$LAYOUT, ForceEarlyReturnLong$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat)
     * }
     */
    public static class ForceEarlyReturnFloat {

        ForceEarlyReturnFloat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnFloat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnFloat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, float _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnFloat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnFloat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat)
     * }
     */
    public static final AddressLayout ForceEarlyReturnFloat$layout() {
        return ForceEarlyReturnFloat$LAYOUT;
    }

    private static final long ForceEarlyReturnFloat$OFFSET = 664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat)
     * }
     */
    public static final long ForceEarlyReturnFloat$offset() {
        return ForceEarlyReturnFloat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat)
     * }
     */
    public static MemorySegment ForceEarlyReturnFloat(MemorySegment struct) {
        return struct.get(ForceEarlyReturnFloat$LAYOUT, ForceEarlyReturnFloat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat)
     * }
     */
    public static void ForceEarlyReturnFloat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnFloat$LAYOUT, ForceEarlyReturnFloat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble)
     * }
     */
    public static class ForceEarlyReturnDouble {

        ForceEarlyReturnDouble() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, double _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_DOUBLE
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnDouble.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnDouble.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, double _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnDouble$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnDouble"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble)
     * }
     */
    public static final AddressLayout ForceEarlyReturnDouble$layout() {
        return ForceEarlyReturnDouble$LAYOUT;
    }

    private static final long ForceEarlyReturnDouble$OFFSET = 672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble)
     * }
     */
    public static final long ForceEarlyReturnDouble$offset() {
        return ForceEarlyReturnDouble$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble)
     * }
     */
    public static MemorySegment ForceEarlyReturnDouble(MemorySegment struct) {
        return struct.get(ForceEarlyReturnDouble$LAYOUT, ForceEarlyReturnDouble$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble)
     * }
     */
    public static void ForceEarlyReturnDouble(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnDouble$LAYOUT, ForceEarlyReturnDouble$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread)
     * }
     */
    public static class ForceEarlyReturnVoid {

        ForceEarlyReturnVoid() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceEarlyReturnVoid.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceEarlyReturnVoid.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceEarlyReturnVoid$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceEarlyReturnVoid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread)
     * }
     */
    public static final AddressLayout ForceEarlyReturnVoid$layout() {
        return ForceEarlyReturnVoid$LAYOUT;
    }

    private static final long ForceEarlyReturnVoid$OFFSET = 680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread)
     * }
     */
    public static final long ForceEarlyReturnVoid$offset() {
        return ForceEarlyReturnVoid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread)
     * }
     */
    public static MemorySegment ForceEarlyReturnVoid(MemorySegment struct) {
        return struct.get(ForceEarlyReturnVoid$LAYOUT, ForceEarlyReturnVoid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread)
     * }
     */
    public static void ForceEarlyReturnVoid(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceEarlyReturnVoid$LAYOUT, ForceEarlyReturnVoid$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *)
     * }
     */
    public static class RedefineClasses {

        RedefineClasses() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RedefineClasses.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RedefineClasses.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RedefineClasses$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RedefineClasses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *)
     * }
     */
    public static final AddressLayout RedefineClasses$layout() {
        return RedefineClasses$LAYOUT;
    }

    private static final long RedefineClasses$OFFSET = 688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *)
     * }
     */
    public static final long RedefineClasses$offset() {
        return RedefineClasses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *)
     * }
     */
    public static MemorySegment RedefineClasses(MemorySegment struct) {
        return struct.get(RedefineClasses$LAYOUT, RedefineClasses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *)
     * }
     */
    public static void RedefineClasses(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RedefineClasses$LAYOUT, RedefineClasses$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *)
     * }
     */
    public static class GetVersionNumber {

        GetVersionNumber() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetVersionNumber.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVersionNumber.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVersionNumber$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVersionNumber"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *)
     * }
     */
    public static final AddressLayout GetVersionNumber$layout() {
        return GetVersionNumber$LAYOUT;
    }

    private static final long GetVersionNumber$OFFSET = 696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *)
     * }
     */
    public static final long GetVersionNumber$offset() {
        return GetVersionNumber$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *)
     * }
     */
    public static MemorySegment GetVersionNumber(MemorySegment struct) {
        return struct.get(GetVersionNumber$LAYOUT, GetVersionNumber$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *)
     * }
     */
    public static void GetVersionNumber(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVersionNumber$LAYOUT, GetVersionNumber$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static class GetCapabilities {

        GetCapabilities() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetCapabilities.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCapabilities.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCapabilities$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCapabilities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static final AddressLayout GetCapabilities$layout() {
        return GetCapabilities$LAYOUT;
    }

    private static final long GetCapabilities$OFFSET = 704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static final long GetCapabilities$offset() {
        return GetCapabilities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static MemorySegment GetCapabilities(MemorySegment struct) {
        return struct.get(GetCapabilities$LAYOUT, GetCapabilities$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static void GetCapabilities(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCapabilities$LAYOUT, GetCapabilities$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static class GetSourceDebugExtension {

        GetSourceDebugExtension() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetSourceDebugExtension.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSourceDebugExtension.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSourceDebugExtension$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSourceDebugExtension"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static final AddressLayout GetSourceDebugExtension$layout() {
        return GetSourceDebugExtension$LAYOUT;
    }

    private static final long GetSourceDebugExtension$OFFSET = 712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static final long GetSourceDebugExtension$offset() {
        return GetSourceDebugExtension$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static MemorySegment GetSourceDebugExtension(MemorySegment struct) {
        return struct.get(GetSourceDebugExtension$LAYOUT, GetSourceDebugExtension$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **)
     * }
     */
    public static void GetSourceDebugExtension(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSourceDebugExtension$LAYOUT, GetSourceDebugExtension$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static class IsMethodObsolete {

        IsMethodObsolete() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsMethodObsolete.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsMethodObsolete.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsMethodObsolete$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsMethodObsolete"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final AddressLayout IsMethodObsolete$layout() {
        return IsMethodObsolete$LAYOUT;
    }

    private static final long IsMethodObsolete$OFFSET = 720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static final long IsMethodObsolete$offset() {
        return IsMethodObsolete$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static MemorySegment IsMethodObsolete(MemorySegment struct) {
        return struct.get(IsMethodObsolete$LAYOUT, IsMethodObsolete$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *)
     * }
     */
    public static void IsMethodObsolete(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsMethodObsolete$LAYOUT, IsMethodObsolete$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static class SuspendThreadList {

        SuspendThreadList() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SuspendThreadList.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SuspendThreadList.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SuspendThreadList$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SuspendThreadList"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static final AddressLayout SuspendThreadList$layout() {
        return SuspendThreadList$LAYOUT;
    }

    private static final long SuspendThreadList$OFFSET = 728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static final long SuspendThreadList$offset() {
        return SuspendThreadList$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static MemorySegment SuspendThreadList(MemorySegment struct) {
        return struct.get(SuspendThreadList$LAYOUT, SuspendThreadList$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static void SuspendThreadList(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SuspendThreadList$LAYOUT, SuspendThreadList$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static class ResumeThreadList {

        ResumeThreadList() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ResumeThreadList.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ResumeThreadList.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ResumeThreadList$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ResumeThreadList"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static final AddressLayout ResumeThreadList$layout() {
        return ResumeThreadList$LAYOUT;
    }

    private static final long ResumeThreadList$OFFSET = 736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static final long ResumeThreadList$offset() {
        return ResumeThreadList$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static MemorySegment ResumeThreadList(MemorySegment struct) {
        return struct.get(ResumeThreadList$LAYOUT, ResumeThreadList$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *)
     * }
     */
    public static void ResumeThreadList(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ResumeThreadList$LAYOUT, ResumeThreadList$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject)
     * }
     */
    public static class AddModuleReads {

        AddModuleReads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddModuleReads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddModuleReads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddModuleReads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddModuleReads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject)
     * }
     */
    public static final AddressLayout AddModuleReads$layout() {
        return AddModuleReads$LAYOUT;
    }

    private static final long AddModuleReads$OFFSET = 744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject)
     * }
     */
    public static final long AddModuleReads$offset() {
        return AddModuleReads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject)
     * }
     */
    public static MemorySegment AddModuleReads(MemorySegment struct) {
        return struct.get(AddModuleReads$LAYOUT, AddModuleReads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject)
     * }
     */
    public static void AddModuleReads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddModuleReads$LAYOUT, AddModuleReads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static class AddModuleExports {

        AddModuleExports() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddModuleExports.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddModuleExports.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddModuleExports$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddModuleExports"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static final AddressLayout AddModuleExports$layout() {
        return AddModuleExports$LAYOUT;
    }

    private static final long AddModuleExports$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static final long AddModuleExports$offset() {
        return AddModuleExports$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static MemorySegment AddModuleExports(MemorySegment struct) {
        return struct.get(AddModuleExports$LAYOUT, AddModuleExports$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static void AddModuleExports(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddModuleExports$LAYOUT, AddModuleExports$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static class AddModuleOpens {

        AddModuleOpens() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddModuleOpens.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddModuleOpens.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddModuleOpens$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddModuleOpens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static final AddressLayout AddModuleOpens$layout() {
        return AddModuleOpens$LAYOUT;
    }

    private static final long AddModuleOpens$OFFSET = 760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static final long AddModuleOpens$offset() {
        return AddModuleOpens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static MemorySegment AddModuleOpens(MemorySegment struct) {
        return struct.get(AddModuleOpens$LAYOUT, AddModuleOpens$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject)
     * }
     */
    public static void AddModuleOpens(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddModuleOpens$LAYOUT, AddModuleOpens$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass)
     * }
     */
    public static class AddModuleUses {

        AddModuleUses() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddModuleUses.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddModuleUses.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddModuleUses$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddModuleUses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass)
     * }
     */
    public static final AddressLayout AddModuleUses$layout() {
        return AddModuleUses$LAYOUT;
    }

    private static final long AddModuleUses$OFFSET = 768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass)
     * }
     */
    public static final long AddModuleUses$offset() {
        return AddModuleUses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass)
     * }
     */
    public static MemorySegment AddModuleUses(MemorySegment struct) {
        return struct.get(AddModuleUses$LAYOUT, AddModuleUses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass)
     * }
     */
    public static void AddModuleUses(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddModuleUses$LAYOUT, AddModuleUses$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass)
     * }
     */
    public static class AddModuleProvides {

        AddModuleProvides() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddModuleProvides.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddModuleProvides.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddModuleProvides$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddModuleProvides"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass)
     * }
     */
    public static final AddressLayout AddModuleProvides$layout() {
        return AddModuleProvides$LAYOUT;
    }

    private static final long AddModuleProvides$OFFSET = 776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass)
     * }
     */
    public static final long AddModuleProvides$offset() {
        return AddModuleProvides$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass)
     * }
     */
    public static MemorySegment AddModuleProvides(MemorySegment struct) {
        return struct.get(AddModuleProvides$LAYOUT, AddModuleProvides$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass)
     * }
     */
    public static void AddModuleProvides(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddModuleProvides$LAYOUT, AddModuleProvides$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *)
     * }
     */
    public static class IsModifiableModule {

        IsModifiableModule() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IsModifiableModule.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsModifiableModule.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsModifiableModule$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsModifiableModule"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *)
     * }
     */
    public static final AddressLayout IsModifiableModule$layout() {
        return IsModifiableModule$LAYOUT;
    }

    private static final long IsModifiableModule$OFFSET = 784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *)
     * }
     */
    public static final long IsModifiableModule$offset() {
        return IsModifiableModule$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *)
     * }
     */
    public static MemorySegment IsModifiableModule(MemorySegment struct) {
        return struct.get(IsModifiableModule$LAYOUT, IsModifiableModule$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *)
     * }
     */
    public static void IsModifiableModule(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsModifiableModule$LAYOUT, IsModifiableModule$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *)
     * }
     */
    public static class GetAllStackTraces {

        GetAllStackTraces() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetAllStackTraces.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllStackTraces.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllStackTraces$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllStackTraces"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *)
     * }
     */
    public static final AddressLayout GetAllStackTraces$layout() {
        return GetAllStackTraces$LAYOUT;
    }

    private static final long GetAllStackTraces$OFFSET = 792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *)
     * }
     */
    public static final long GetAllStackTraces$offset() {
        return GetAllStackTraces$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *)
     * }
     */
    public static MemorySegment GetAllStackTraces(MemorySegment struct) {
        return struct.get(GetAllStackTraces$LAYOUT, GetAllStackTraces$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *)
     * }
     */
    public static void GetAllStackTraces(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllStackTraces$LAYOUT, GetAllStackTraces$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **)
     * }
     */
    public static class GetThreadListStackTraces {

        GetThreadListStackTraces() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadListStackTraces.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadListStackTraces.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadListStackTraces$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadListStackTraces"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **)
     * }
     */
    public static final AddressLayout GetThreadListStackTraces$layout() {
        return GetThreadListStackTraces$LAYOUT;
    }

    private static final long GetThreadListStackTraces$OFFSET = 800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **)
     * }
     */
    public static final long GetThreadListStackTraces$offset() {
        return GetThreadListStackTraces$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **)
     * }
     */
    public static MemorySegment GetThreadListStackTraces(MemorySegment struct) {
        return struct.get(GetThreadListStackTraces$LAYOUT, GetThreadListStackTraces$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **)
     * }
     */
    public static void GetThreadListStackTraces(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadListStackTraces$LAYOUT, GetThreadListStackTraces$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **)
     * }
     */
    public static class GetThreadLocalStorage {

        GetThreadLocalStorage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadLocalStorage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadLocalStorage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadLocalStorage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadLocalStorage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **)
     * }
     */
    public static final AddressLayout GetThreadLocalStorage$layout() {
        return GetThreadLocalStorage$LAYOUT;
    }

    private static final long GetThreadLocalStorage$OFFSET = 808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **)
     * }
     */
    public static final long GetThreadLocalStorage$offset() {
        return GetThreadLocalStorage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **)
     * }
     */
    public static MemorySegment GetThreadLocalStorage(MemorySegment struct) {
        return struct.get(GetThreadLocalStorage$LAYOUT, GetThreadLocalStorage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **)
     * }
     */
    public static void GetThreadLocalStorage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadLocalStorage$LAYOUT, GetThreadLocalStorage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *)
     * }
     */
    public static class SetThreadLocalStorage {

        SetThreadLocalStorage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetThreadLocalStorage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetThreadLocalStorage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetThreadLocalStorage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetThreadLocalStorage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *)
     * }
     */
    public static final AddressLayout SetThreadLocalStorage$layout() {
        return SetThreadLocalStorage$LAYOUT;
    }

    private static final long SetThreadLocalStorage$OFFSET = 816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *)
     * }
     */
    public static final long SetThreadLocalStorage$offset() {
        return SetThreadLocalStorage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *)
     * }
     */
    public static MemorySegment SetThreadLocalStorage(MemorySegment struct) {
        return struct.get(SetThreadLocalStorage$LAYOUT, SetThreadLocalStorage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *)
     * }
     */
    public static void SetThreadLocalStorage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetThreadLocalStorage$LAYOUT, SetThreadLocalStorage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *)
     * }
     */
    public static class GetStackTrace {

        GetStackTrace() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetStackTrace.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStackTrace.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStackTrace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStackTrace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *)
     * }
     */
    public static final AddressLayout GetStackTrace$layout() {
        return GetStackTrace$LAYOUT;
    }

    private static final long GetStackTrace$OFFSET = 824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *)
     * }
     */
    public static final long GetStackTrace$offset() {
        return GetStackTrace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *)
     * }
     */
    public static MemorySegment GetStackTrace(MemorySegment struct) {
        return struct.get(GetStackTrace$LAYOUT, GetStackTrace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *)
     * }
     */
    public static void GetStackTrace(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStackTrace$LAYOUT, GetStackTrace$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved105$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved105"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved105
     * }
     */
    public static final AddressLayout reserved105$layout() {
        return reserved105$LAYOUT;
    }

    private static final long reserved105$OFFSET = 832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved105
     * }
     */
    public static final long reserved105$offset() {
        return reserved105$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved105
     * }
     */
    public static MemorySegment reserved105(MemorySegment struct) {
        return struct.get(reserved105$LAYOUT, reserved105$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved105
     * }
     */
    public static void reserved105(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved105$LAYOUT, reserved105$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static class GetTag {

        GetTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static final AddressLayout GetTag$layout() {
        return GetTag$LAYOUT;
    }

    private static final long GetTag$OFFSET = 840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static final long GetTag$offset() {
        return GetTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static MemorySegment GetTag(MemorySegment struct) {
        return struct.get(GetTag$LAYOUT, GetTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static void GetTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTag$LAYOUT, GetTag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong)
     * }
     */
    public static class SetTag {

        SetTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong)
     * }
     */
    public static final AddressLayout SetTag$layout() {
        return SetTag$LAYOUT;
    }

    private static final long SetTag$OFFSET = 848;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong)
     * }
     */
    public static final long SetTag$offset() {
        return SetTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong)
     * }
     */
    public static MemorySegment SetTag(MemorySegment struct) {
        return struct.get(SetTag$LAYOUT, SetTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong)
     * }
     */
    public static void SetTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetTag$LAYOUT, SetTag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ForceGarbageCollection)(jvmtiEnv *)
     * }
     */
    public static class ForceGarbageCollection {

        ForceGarbageCollection() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ForceGarbageCollection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ForceGarbageCollection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ForceGarbageCollection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ForceGarbageCollection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceGarbageCollection)(jvmtiEnv *)
     * }
     */
    public static final AddressLayout ForceGarbageCollection$layout() {
        return ForceGarbageCollection$LAYOUT;
    }

    private static final long ForceGarbageCollection$OFFSET = 856;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceGarbageCollection)(jvmtiEnv *)
     * }
     */
    public static final long ForceGarbageCollection$offset() {
        return ForceGarbageCollection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceGarbageCollection)(jvmtiEnv *)
     * }
     */
    public static MemorySegment ForceGarbageCollection(MemorySegment struct) {
        return struct.get(ForceGarbageCollection$LAYOUT, ForceGarbageCollection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ForceGarbageCollection)(jvmtiEnv *)
     * }
     */
    public static void ForceGarbageCollection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ForceGarbageCollection$LAYOUT, ForceGarbageCollection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static class IterateOverObjectsReachableFromObject {

        IterateOverObjectsReachableFromObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IterateOverObjectsReachableFromObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IterateOverObjectsReachableFromObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IterateOverObjectsReachableFromObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IterateOverObjectsReachableFromObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static final AddressLayout IterateOverObjectsReachableFromObject$layout() {
        return IterateOverObjectsReachableFromObject$LAYOUT;
    }

    private static final long IterateOverObjectsReachableFromObject$OFFSET = 864;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static final long IterateOverObjectsReachableFromObject$offset() {
        return IterateOverObjectsReachableFromObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static MemorySegment IterateOverObjectsReachableFromObject(MemorySegment struct) {
        return struct.get(IterateOverObjectsReachableFromObject$LAYOUT, IterateOverObjectsReachableFromObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static void IterateOverObjectsReachableFromObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IterateOverObjectsReachableFromObject$LAYOUT, IterateOverObjectsReachableFromObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static class IterateOverReachableObjects {

        IterateOverReachableObjects() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IterateOverReachableObjects.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IterateOverReachableObjects.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IterateOverReachableObjects$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IterateOverReachableObjects"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static final AddressLayout IterateOverReachableObjects$layout() {
        return IterateOverReachableObjects$LAYOUT;
    }

    private static final long IterateOverReachableObjects$OFFSET = 872;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static final long IterateOverReachableObjects$offset() {
        return IterateOverReachableObjects$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static MemorySegment IterateOverReachableObjects(MemorySegment struct) {
        return struct.get(IterateOverReachableObjects$LAYOUT, IterateOverReachableObjects$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *)
     * }
     */
    public static void IterateOverReachableObjects(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IterateOverReachableObjects$LAYOUT, IterateOverReachableObjects$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static class IterateOverHeap {

        IterateOverHeap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IterateOverHeap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IterateOverHeap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IterateOverHeap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IterateOverHeap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static final AddressLayout IterateOverHeap$layout() {
        return IterateOverHeap$LAYOUT;
    }

    private static final long IterateOverHeap$OFFSET = 880;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static final long IterateOverHeap$offset() {
        return IterateOverHeap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static MemorySegment IterateOverHeap(MemorySegment struct) {
        return struct.get(IterateOverHeap$LAYOUT, IterateOverHeap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static void IterateOverHeap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IterateOverHeap$LAYOUT, IterateOverHeap$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static class IterateOverInstancesOfClass {

        IterateOverInstancesOfClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IterateOverInstancesOfClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IterateOverInstancesOfClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IterateOverInstancesOfClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IterateOverInstancesOfClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static final AddressLayout IterateOverInstancesOfClass$layout() {
        return IterateOverInstancesOfClass$LAYOUT;
    }

    private static final long IterateOverInstancesOfClass$OFFSET = 888;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static final long IterateOverInstancesOfClass$offset() {
        return IterateOverInstancesOfClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static MemorySegment IterateOverInstancesOfClass(MemorySegment struct) {
        return struct.get(IterateOverInstancesOfClass$LAYOUT, IterateOverInstancesOfClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *)
     * }
     */
    public static void IterateOverInstancesOfClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IterateOverInstancesOfClass$LAYOUT, IterateOverInstancesOfClass$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved113$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved113"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved113
     * }
     */
    public static final AddressLayout reserved113$layout() {
        return reserved113$LAYOUT;
    }

    private static final long reserved113$OFFSET = 896;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved113
     * }
     */
    public static final long reserved113$offset() {
        return reserved113$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved113
     * }
     */
    public static MemorySegment reserved113(MemorySegment struct) {
        return struct.get(reserved113$LAYOUT, reserved113$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved113
     * }
     */
    public static void reserved113(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved113$LAYOUT, reserved113$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **)
     * }
     */
    public static class GetObjectsWithTags {

        GetObjectsWithTags() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetObjectsWithTags.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectsWithTags.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectsWithTags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectsWithTags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **)
     * }
     */
    public static final AddressLayout GetObjectsWithTags$layout() {
        return GetObjectsWithTags$LAYOUT;
    }

    private static final long GetObjectsWithTags$OFFSET = 904;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **)
     * }
     */
    public static final long GetObjectsWithTags$offset() {
        return GetObjectsWithTags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **)
     * }
     */
    public static MemorySegment GetObjectsWithTags(MemorySegment struct) {
        return struct.get(GetObjectsWithTags$LAYOUT, GetObjectsWithTags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **)
     * }
     */
    public static void GetObjectsWithTags(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectsWithTags$LAYOUT, GetObjectsWithTags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static class FollowReferences {

        FollowReferences() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(FollowReferences.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FollowReferences.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FollowReferences$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FollowReferences"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static final AddressLayout FollowReferences$layout() {
        return FollowReferences$LAYOUT;
    }

    private static final long FollowReferences$OFFSET = 912;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static final long FollowReferences$offset() {
        return FollowReferences$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static MemorySegment FollowReferences(MemorySegment struct) {
        return struct.get(FollowReferences$LAYOUT, FollowReferences$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static void FollowReferences(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FollowReferences$LAYOUT, FollowReferences$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static class IterateThroughHeap {

        IterateThroughHeap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(IterateThroughHeap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IterateThroughHeap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IterateThroughHeap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IterateThroughHeap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static final AddressLayout IterateThroughHeap$layout() {
        return IterateThroughHeap$LAYOUT;
    }

    private static final long IterateThroughHeap$OFFSET = 920;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static final long IterateThroughHeap$offset() {
        return IterateThroughHeap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static MemorySegment IterateThroughHeap(MemorySegment struct) {
        return struct.get(IterateThroughHeap$LAYOUT, IterateThroughHeap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *)
     * }
     */
    public static void IterateThroughHeap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IterateThroughHeap$LAYOUT, IterateThroughHeap$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved117$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved117"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved117
     * }
     */
    public static final AddressLayout reserved117$layout() {
        return reserved117$LAYOUT;
    }

    private static final long reserved117$OFFSET = 928;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved117
     * }
     */
    public static final long reserved117$offset() {
        return reserved117$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved117
     * }
     */
    public static MemorySegment reserved117(MemorySegment struct) {
        return struct.get(reserved117$LAYOUT, reserved117$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved117
     * }
     */
    public static void reserved117(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved117$LAYOUT, reserved117$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static class SuspendAllVirtualThreads {

        SuspendAllVirtualThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SuspendAllVirtualThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SuspendAllVirtualThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SuspendAllVirtualThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SuspendAllVirtualThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static final AddressLayout SuspendAllVirtualThreads$layout() {
        return SuspendAllVirtualThreads$LAYOUT;
    }

    private static final long SuspendAllVirtualThreads$OFFSET = 936;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static final long SuspendAllVirtualThreads$offset() {
        return SuspendAllVirtualThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static MemorySegment SuspendAllVirtualThreads(MemorySegment struct) {
        return struct.get(SuspendAllVirtualThreads$LAYOUT, SuspendAllVirtualThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static void SuspendAllVirtualThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SuspendAllVirtualThreads$LAYOUT, SuspendAllVirtualThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static class ResumeAllVirtualThreads {

        ResumeAllVirtualThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(ResumeAllVirtualThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ResumeAllVirtualThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ResumeAllVirtualThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ResumeAllVirtualThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static final AddressLayout ResumeAllVirtualThreads$layout() {
        return ResumeAllVirtualThreads$LAYOUT;
    }

    private static final long ResumeAllVirtualThreads$OFFSET = 944;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static final long ResumeAllVirtualThreads$offset() {
        return ResumeAllVirtualThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static MemorySegment ResumeAllVirtualThreads(MemorySegment struct) {
        return struct.get(ResumeAllVirtualThreads$LAYOUT, ResumeAllVirtualThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *)
     * }
     */
    public static void ResumeAllVirtualThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ResumeAllVirtualThreads$LAYOUT, ResumeAllVirtualThreads$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *)
     * }
     */
    public static class SetJNIFunctionTable {

        SetJNIFunctionTable() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetJNIFunctionTable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetJNIFunctionTable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetJNIFunctionTable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetJNIFunctionTable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *)
     * }
     */
    public static final AddressLayout SetJNIFunctionTable$layout() {
        return SetJNIFunctionTable$LAYOUT;
    }

    private static final long SetJNIFunctionTable$OFFSET = 952;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *)
     * }
     */
    public static final long SetJNIFunctionTable$offset() {
        return SetJNIFunctionTable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *)
     * }
     */
    public static MemorySegment SetJNIFunctionTable(MemorySegment struct) {
        return struct.get(SetJNIFunctionTable$LAYOUT, SetJNIFunctionTable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *)
     * }
     */
    public static void SetJNIFunctionTable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetJNIFunctionTable$LAYOUT, SetJNIFunctionTable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **)
     * }
     */
    public static class GetJNIFunctionTable {

        GetJNIFunctionTable() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetJNIFunctionTable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetJNIFunctionTable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetJNIFunctionTable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetJNIFunctionTable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **)
     * }
     */
    public static final AddressLayout GetJNIFunctionTable$layout() {
        return GetJNIFunctionTable$LAYOUT;
    }

    private static final long GetJNIFunctionTable$OFFSET = 960;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **)
     * }
     */
    public static final long GetJNIFunctionTable$offset() {
        return GetJNIFunctionTable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **)
     * }
     */
    public static MemorySegment GetJNIFunctionTable(MemorySegment struct) {
        return struct.get(GetJNIFunctionTable$LAYOUT, GetJNIFunctionTable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **)
     * }
     */
    public static void GetJNIFunctionTable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetJNIFunctionTable$LAYOUT, GetJNIFunctionTable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint)
     * }
     */
    public static class SetEventCallbacks {

        SetEventCallbacks() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetEventCallbacks.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetEventCallbacks.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetEventCallbacks$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetEventCallbacks"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint)
     * }
     */
    public static final AddressLayout SetEventCallbacks$layout() {
        return SetEventCallbacks$LAYOUT;
    }

    private static final long SetEventCallbacks$OFFSET = 968;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint)
     * }
     */
    public static final long SetEventCallbacks$offset() {
        return SetEventCallbacks$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint)
     * }
     */
    public static MemorySegment SetEventCallbacks(MemorySegment struct) {
        return struct.get(SetEventCallbacks$LAYOUT, SetEventCallbacks$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint)
     * }
     */
    public static void SetEventCallbacks(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetEventCallbacks$LAYOUT, SetEventCallbacks$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent)
     * }
     */
    public static class GenerateEvents {

        GenerateEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GenerateEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GenerateEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GenerateEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GenerateEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent)
     * }
     */
    public static final AddressLayout GenerateEvents$layout() {
        return GenerateEvents$LAYOUT;
    }

    private static final long GenerateEvents$OFFSET = 976;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent)
     * }
     */
    public static final long GenerateEvents$offset() {
        return GenerateEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent)
     * }
     */
    public static MemorySegment GenerateEvents(MemorySegment struct) {
        return struct.get(GenerateEvents$LAYOUT, GenerateEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent)
     * }
     */
    public static void GenerateEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GenerateEvents$LAYOUT, GenerateEvents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **)
     * }
     */
    public static class GetExtensionFunctions {

        GetExtensionFunctions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetExtensionFunctions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExtensionFunctions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExtensionFunctions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExtensionFunctions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **)
     * }
     */
    public static final AddressLayout GetExtensionFunctions$layout() {
        return GetExtensionFunctions$LAYOUT;
    }

    private static final long GetExtensionFunctions$OFFSET = 984;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **)
     * }
     */
    public static final long GetExtensionFunctions$offset() {
        return GetExtensionFunctions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **)
     * }
     */
    public static MemorySegment GetExtensionFunctions(MemorySegment struct) {
        return struct.get(GetExtensionFunctions$LAYOUT, GetExtensionFunctions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **)
     * }
     */
    public static void GetExtensionFunctions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExtensionFunctions$LAYOUT, GetExtensionFunctions$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **)
     * }
     */
    public static class GetExtensionEvents {

        GetExtensionEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetExtensionEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExtensionEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExtensionEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExtensionEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **)
     * }
     */
    public static final AddressLayout GetExtensionEvents$layout() {
        return GetExtensionEvents$LAYOUT;
    }

    private static final long GetExtensionEvents$OFFSET = 992;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **)
     * }
     */
    public static final long GetExtensionEvents$offset() {
        return GetExtensionEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **)
     * }
     */
    public static MemorySegment GetExtensionEvents(MemorySegment struct) {
        return struct.get(GetExtensionEvents$LAYOUT, GetExtensionEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **)
     * }
     */
    public static void GetExtensionEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExtensionEvents$LAYOUT, GetExtensionEvents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent)
     * }
     */
    public static class SetExtensionEventCallback {

        SetExtensionEventCallback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetExtensionEventCallback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetExtensionEventCallback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetExtensionEventCallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetExtensionEventCallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent)
     * }
     */
    public static final AddressLayout SetExtensionEventCallback$layout() {
        return SetExtensionEventCallback$LAYOUT;
    }

    private static final long SetExtensionEventCallback$OFFSET = 1000;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent)
     * }
     */
    public static final long SetExtensionEventCallback$offset() {
        return SetExtensionEventCallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent)
     * }
     */
    public static MemorySegment SetExtensionEventCallback(MemorySegment struct) {
        return struct.get(SetExtensionEventCallback$LAYOUT, SetExtensionEventCallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent)
     * }
     */
    public static void SetExtensionEventCallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetExtensionEventCallback$LAYOUT, SetExtensionEventCallback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*DisposeEnvironment)(jvmtiEnv *)
     * }
     */
    public static class DisposeEnvironment {

        DisposeEnvironment() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(DisposeEnvironment.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisposeEnvironment.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisposeEnvironment$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisposeEnvironment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*DisposeEnvironment)(jvmtiEnv *)
     * }
     */
    public static final AddressLayout DisposeEnvironment$layout() {
        return DisposeEnvironment$LAYOUT;
    }

    private static final long DisposeEnvironment$OFFSET = 1008;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*DisposeEnvironment)(jvmtiEnv *)
     * }
     */
    public static final long DisposeEnvironment$offset() {
        return DisposeEnvironment$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*DisposeEnvironment)(jvmtiEnv *)
     * }
     */
    public static MemorySegment DisposeEnvironment(MemorySegment struct) {
        return struct.get(DisposeEnvironment$LAYOUT, DisposeEnvironment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*DisposeEnvironment)(jvmtiEnv *)
     * }
     */
    public static void DisposeEnvironment(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisposeEnvironment$LAYOUT, DisposeEnvironment$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **)
     * }
     */
    public static class GetErrorName {

        GetErrorName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetErrorName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetErrorName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetErrorName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetErrorName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **)
     * }
     */
    public static final AddressLayout GetErrorName$layout() {
        return GetErrorName$LAYOUT;
    }

    private static final long GetErrorName$OFFSET = 1016;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **)
     * }
     */
    public static final long GetErrorName$offset() {
        return GetErrorName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **)
     * }
     */
    public static MemorySegment GetErrorName(MemorySegment struct) {
        return struct.get(GetErrorName$LAYOUT, GetErrorName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **)
     * }
     */
    public static void GetErrorName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetErrorName$LAYOUT, GetErrorName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *)
     * }
     */
    public static class GetJLocationFormat {

        GetJLocationFormat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetJLocationFormat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetJLocationFormat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetJLocationFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetJLocationFormat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *)
     * }
     */
    public static final AddressLayout GetJLocationFormat$layout() {
        return GetJLocationFormat$LAYOUT;
    }

    private static final long GetJLocationFormat$OFFSET = 1024;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *)
     * }
     */
    public static final long GetJLocationFormat$offset() {
        return GetJLocationFormat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *)
     * }
     */
    public static MemorySegment GetJLocationFormat(MemorySegment struct) {
        return struct.get(GetJLocationFormat$LAYOUT, GetJLocationFormat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *)
     * }
     */
    public static void GetJLocationFormat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetJLocationFormat$LAYOUT, GetJLocationFormat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***)
     * }
     */
    public static class GetSystemProperties {

        GetSystemProperties() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetSystemProperties.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSystemProperties.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSystemProperties$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSystemProperties"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***)
     * }
     */
    public static final AddressLayout GetSystemProperties$layout() {
        return GetSystemProperties$LAYOUT;
    }

    private static final long GetSystemProperties$OFFSET = 1032;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***)
     * }
     */
    public static final long GetSystemProperties$offset() {
        return GetSystemProperties$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***)
     * }
     */
    public static MemorySegment GetSystemProperties(MemorySegment struct) {
        return struct.get(GetSystemProperties$LAYOUT, GetSystemProperties$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***)
     * }
     */
    public static void GetSystemProperties(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSystemProperties$LAYOUT, GetSystemProperties$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **)
     * }
     */
    public static class GetSystemProperty {

        GetSystemProperty() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetSystemProperty.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSystemProperty.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSystemProperty$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSystemProperty"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **)
     * }
     */
    public static final AddressLayout GetSystemProperty$layout() {
        return GetSystemProperty$LAYOUT;
    }

    private static final long GetSystemProperty$OFFSET = 1040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **)
     * }
     */
    public static final long GetSystemProperty$offset() {
        return GetSystemProperty$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **)
     * }
     */
    public static MemorySegment GetSystemProperty(MemorySegment struct) {
        return struct.get(GetSystemProperty$LAYOUT, GetSystemProperty$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **)
     * }
     */
    public static void GetSystemProperty(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSystemProperty$LAYOUT, GetSystemProperty$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *)
     * }
     */
    public static class SetSystemProperty {

        SetSystemProperty() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetSystemProperty.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSystemProperty.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSystemProperty$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSystemProperty"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *)
     * }
     */
    public static final AddressLayout SetSystemProperty$layout() {
        return SetSystemProperty$LAYOUT;
    }

    private static final long SetSystemProperty$OFFSET = 1048;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *)
     * }
     */
    public static final long SetSystemProperty$offset() {
        return SetSystemProperty$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *)
     * }
     */
    public static MemorySegment SetSystemProperty(MemorySegment struct) {
        return struct.get(SetSystemProperty$LAYOUT, SetSystemProperty$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *)
     * }
     */
    public static void SetSystemProperty(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSystemProperty$LAYOUT, SetSystemProperty$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *)
     * }
     */
    public static class GetPhase {

        GetPhase() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetPhase.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPhase.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPhase$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPhase"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *)
     * }
     */
    public static final AddressLayout GetPhase$layout() {
        return GetPhase$LAYOUT;
    }

    private static final long GetPhase$OFFSET = 1056;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *)
     * }
     */
    public static final long GetPhase$offset() {
        return GetPhase$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *)
     * }
     */
    public static MemorySegment GetPhase(MemorySegment struct) {
        return struct.get(GetPhase$LAYOUT, GetPhase$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *)
     * }
     */
    public static void GetPhase(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPhase$LAYOUT, GetPhase$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static class GetCurrentThreadCpuTimerInfo {

        GetCurrentThreadCpuTimerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetCurrentThreadCpuTimerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentThreadCpuTimerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentThreadCpuTimerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentThreadCpuTimerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final AddressLayout GetCurrentThreadCpuTimerInfo$layout() {
        return GetCurrentThreadCpuTimerInfo$LAYOUT;
    }

    private static final long GetCurrentThreadCpuTimerInfo$OFFSET = 1064;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final long GetCurrentThreadCpuTimerInfo$offset() {
        return GetCurrentThreadCpuTimerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static MemorySegment GetCurrentThreadCpuTimerInfo(MemorySegment struct) {
        return struct.get(GetCurrentThreadCpuTimerInfo$LAYOUT, GetCurrentThreadCpuTimerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static void GetCurrentThreadCpuTimerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentThreadCpuTimerInfo$LAYOUT, GetCurrentThreadCpuTimerInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static class GetCurrentThreadCpuTime {

        GetCurrentThreadCpuTime() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetCurrentThreadCpuTime.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentThreadCpuTime.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentThreadCpuTime$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentThreadCpuTime"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static final AddressLayout GetCurrentThreadCpuTime$layout() {
        return GetCurrentThreadCpuTime$LAYOUT;
    }

    private static final long GetCurrentThreadCpuTime$OFFSET = 1072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static final long GetCurrentThreadCpuTime$offset() {
        return GetCurrentThreadCpuTime$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static MemorySegment GetCurrentThreadCpuTime(MemorySegment struct) {
        return struct.get(GetCurrentThreadCpuTime$LAYOUT, GetCurrentThreadCpuTime$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static void GetCurrentThreadCpuTime(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentThreadCpuTime$LAYOUT, GetCurrentThreadCpuTime$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static class GetThreadCpuTimerInfo {

        GetThreadCpuTimerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadCpuTimerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadCpuTimerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadCpuTimerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadCpuTimerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final AddressLayout GetThreadCpuTimerInfo$layout() {
        return GetThreadCpuTimerInfo$LAYOUT;
    }

    private static final long GetThreadCpuTimerInfo$OFFSET = 1080;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final long GetThreadCpuTimerInfo$offset() {
        return GetThreadCpuTimerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static MemorySegment GetThreadCpuTimerInfo(MemorySegment struct) {
        return struct.get(GetThreadCpuTimerInfo$LAYOUT, GetThreadCpuTimerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static void GetThreadCpuTimerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadCpuTimerInfo$LAYOUT, GetThreadCpuTimerInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *)
     * }
     */
    public static class GetThreadCpuTime {

        GetThreadCpuTime() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetThreadCpuTime.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetThreadCpuTime.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetThreadCpuTime$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetThreadCpuTime"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *)
     * }
     */
    public static final AddressLayout GetThreadCpuTime$layout() {
        return GetThreadCpuTime$LAYOUT;
    }

    private static final long GetThreadCpuTime$OFFSET = 1088;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *)
     * }
     */
    public static final long GetThreadCpuTime$offset() {
        return GetThreadCpuTime$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *)
     * }
     */
    public static MemorySegment GetThreadCpuTime(MemorySegment struct) {
        return struct.get(GetThreadCpuTime$LAYOUT, GetThreadCpuTime$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *)
     * }
     */
    public static void GetThreadCpuTime(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetThreadCpuTime$LAYOUT, GetThreadCpuTime$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static class GetTimerInfo {

        GetTimerInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetTimerInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTimerInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTimerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTimerInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final AddressLayout GetTimerInfo$layout() {
        return GetTimerInfo$LAYOUT;
    }

    private static final long GetTimerInfo$OFFSET = 1096;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static final long GetTimerInfo$offset() {
        return GetTimerInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static MemorySegment GetTimerInfo(MemorySegment struct) {
        return struct.get(GetTimerInfo$LAYOUT, GetTimerInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *)
     * }
     */
    public static void GetTimerInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTimerInfo$LAYOUT, GetTimerInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static class GetTime {

        GetTime() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetTime.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTime.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTime$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTime"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static final AddressLayout GetTime$layout() {
        return GetTime$LAYOUT;
    }

    private static final long GetTime$OFFSET = 1104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static final long GetTime$offset() {
        return GetTime$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static MemorySegment GetTime(MemorySegment struct) {
        return struct.get(GetTime$LAYOUT, GetTime$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetTime)(jvmtiEnv *, jlong *)
     * }
     */
    public static void GetTime(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTime$LAYOUT, GetTime$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static class GetPotentialCapabilities {

        GetPotentialCapabilities() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetPotentialCapabilities.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPotentialCapabilities.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPotentialCapabilities$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPotentialCapabilities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static final AddressLayout GetPotentialCapabilities$layout() {
        return GetPotentialCapabilities$LAYOUT;
    }

    private static final long GetPotentialCapabilities$OFFSET = 1112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static final long GetPotentialCapabilities$offset() {
        return GetPotentialCapabilities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static MemorySegment GetPotentialCapabilities(MemorySegment struct) {
        return struct.get(GetPotentialCapabilities$LAYOUT, GetPotentialCapabilities$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *)
     * }
     */
    public static void GetPotentialCapabilities(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPotentialCapabilities$LAYOUT, GetPotentialCapabilities$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved141$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved141"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved141
     * }
     */
    public static final AddressLayout reserved141$layout() {
        return reserved141$LAYOUT;
    }

    private static final long reserved141$OFFSET = 1120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved141
     * }
     */
    public static final long reserved141$offset() {
        return reserved141$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved141
     * }
     */
    public static MemorySegment reserved141(MemorySegment struct) {
        return struct.get(reserved141$LAYOUT, reserved141$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved141
     * }
     */
    public static void reserved141(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved141$LAYOUT, reserved141$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static class AddCapabilities {

        AddCapabilities() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddCapabilities.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddCapabilities.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddCapabilities$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddCapabilities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static final AddressLayout AddCapabilities$layout() {
        return AddCapabilities$LAYOUT;
    }

    private static final long AddCapabilities$OFFSET = 1128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static final long AddCapabilities$offset() {
        return AddCapabilities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static MemorySegment AddCapabilities(MemorySegment struct) {
        return struct.get(AddCapabilities$LAYOUT, AddCapabilities$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static void AddCapabilities(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddCapabilities$LAYOUT, AddCapabilities$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static class RelinquishCapabilities {

        RelinquishCapabilities() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RelinquishCapabilities.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RelinquishCapabilities.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RelinquishCapabilities$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RelinquishCapabilities"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static final AddressLayout RelinquishCapabilities$layout() {
        return RelinquishCapabilities$LAYOUT;
    }

    private static final long RelinquishCapabilities$OFFSET = 1136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static final long RelinquishCapabilities$offset() {
        return RelinquishCapabilities$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static MemorySegment RelinquishCapabilities(MemorySegment struct) {
        return struct.get(RelinquishCapabilities$LAYOUT, RelinquishCapabilities$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *)
     * }
     */
    public static void RelinquishCapabilities(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RelinquishCapabilities$LAYOUT, RelinquishCapabilities$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *)
     * }
     */
    public static class GetAvailableProcessors {

        GetAvailableProcessors() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetAvailableProcessors.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAvailableProcessors.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAvailableProcessors$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAvailableProcessors"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *)
     * }
     */
    public static final AddressLayout GetAvailableProcessors$layout() {
        return GetAvailableProcessors$LAYOUT;
    }

    private static final long GetAvailableProcessors$OFFSET = 1144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *)
     * }
     */
    public static final long GetAvailableProcessors$offset() {
        return GetAvailableProcessors$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *)
     * }
     */
    public static MemorySegment GetAvailableProcessors(MemorySegment struct) {
        return struct.get(GetAvailableProcessors$LAYOUT, GetAvailableProcessors$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *)
     * }
     */
    public static void GetAvailableProcessors(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAvailableProcessors$LAYOUT, GetAvailableProcessors$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *)
     * }
     */
    public static class GetClassVersionNumbers {

        GetClassVersionNumbers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetClassVersionNumbers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetClassVersionNumbers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetClassVersionNumbers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetClassVersionNumbers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *)
     * }
     */
    public static final AddressLayout GetClassVersionNumbers$layout() {
        return GetClassVersionNumbers$LAYOUT;
    }

    private static final long GetClassVersionNumbers$OFFSET = 1152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *)
     * }
     */
    public static final long GetClassVersionNumbers$offset() {
        return GetClassVersionNumbers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *)
     * }
     */
    public static MemorySegment GetClassVersionNumbers(MemorySegment struct) {
        return struct.get(GetClassVersionNumbers$LAYOUT, GetClassVersionNumbers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *)
     * }
     */
    public static void GetClassVersionNumbers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetClassVersionNumbers$LAYOUT, GetClassVersionNumbers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **)
     * }
     */
    public static class GetConstantPool {

        GetConstantPool() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetConstantPool.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetConstantPool.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetConstantPool$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetConstantPool"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **)
     * }
     */
    public static final AddressLayout GetConstantPool$layout() {
        return GetConstantPool$LAYOUT;
    }

    private static final long GetConstantPool$OFFSET = 1160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **)
     * }
     */
    public static final long GetConstantPool$offset() {
        return GetConstantPool$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **)
     * }
     */
    public static MemorySegment GetConstantPool(MemorySegment struct) {
        return struct.get(GetConstantPool$LAYOUT, GetConstantPool$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **)
     * }
     */
    public static void GetConstantPool(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetConstantPool$LAYOUT, GetConstantPool$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **)
     * }
     */
    public static class GetEnvironmentLocalStorage {

        GetEnvironmentLocalStorage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetEnvironmentLocalStorage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetEnvironmentLocalStorage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetEnvironmentLocalStorage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetEnvironmentLocalStorage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **)
     * }
     */
    public static final AddressLayout GetEnvironmentLocalStorage$layout() {
        return GetEnvironmentLocalStorage$LAYOUT;
    }

    private static final long GetEnvironmentLocalStorage$OFFSET = 1168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **)
     * }
     */
    public static final long GetEnvironmentLocalStorage$offset() {
        return GetEnvironmentLocalStorage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **)
     * }
     */
    public static MemorySegment GetEnvironmentLocalStorage(MemorySegment struct) {
        return struct.get(GetEnvironmentLocalStorage$LAYOUT, GetEnvironmentLocalStorage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **)
     * }
     */
    public static void GetEnvironmentLocalStorage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetEnvironmentLocalStorage$LAYOUT, GetEnvironmentLocalStorage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *)
     * }
     */
    public static class SetEnvironmentLocalStorage {

        SetEnvironmentLocalStorage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetEnvironmentLocalStorage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetEnvironmentLocalStorage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetEnvironmentLocalStorage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetEnvironmentLocalStorage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *)
     * }
     */
    public static final AddressLayout SetEnvironmentLocalStorage$layout() {
        return SetEnvironmentLocalStorage$LAYOUT;
    }

    private static final long SetEnvironmentLocalStorage$OFFSET = 1176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *)
     * }
     */
    public static final long SetEnvironmentLocalStorage$offset() {
        return SetEnvironmentLocalStorage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *)
     * }
     */
    public static MemorySegment SetEnvironmentLocalStorage(MemorySegment struct) {
        return struct.get(SetEnvironmentLocalStorage$LAYOUT, SetEnvironmentLocalStorage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *)
     * }
     */
    public static void SetEnvironmentLocalStorage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetEnvironmentLocalStorage$LAYOUT, SetEnvironmentLocalStorage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static class AddToBootstrapClassLoaderSearch {

        AddToBootstrapClassLoaderSearch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddToBootstrapClassLoaderSearch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddToBootstrapClassLoaderSearch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddToBootstrapClassLoaderSearch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddToBootstrapClassLoaderSearch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static final AddressLayout AddToBootstrapClassLoaderSearch$layout() {
        return AddToBootstrapClassLoaderSearch$LAYOUT;
    }

    private static final long AddToBootstrapClassLoaderSearch$OFFSET = 1184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static final long AddToBootstrapClassLoaderSearch$offset() {
        return AddToBootstrapClassLoaderSearch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static MemorySegment AddToBootstrapClassLoaderSearch(MemorySegment struct) {
        return struct.get(AddToBootstrapClassLoaderSearch$LAYOUT, AddToBootstrapClassLoaderSearch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static void AddToBootstrapClassLoaderSearch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddToBootstrapClassLoaderSearch$LAYOUT, AddToBootstrapClassLoaderSearch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean)
     * }
     */
    public static class SetVerboseFlag {

        SetVerboseFlag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, byte _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetVerboseFlag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetVerboseFlag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, byte _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetVerboseFlag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetVerboseFlag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean)
     * }
     */
    public static final AddressLayout SetVerboseFlag$layout() {
        return SetVerboseFlag$LAYOUT;
    }

    private static final long SetVerboseFlag$OFFSET = 1192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean)
     * }
     */
    public static final long SetVerboseFlag$offset() {
        return SetVerboseFlag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean)
     * }
     */
    public static MemorySegment SetVerboseFlag(MemorySegment struct) {
        return struct.get(SetVerboseFlag$LAYOUT, SetVerboseFlag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean)
     * }
     */
    public static void SetVerboseFlag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetVerboseFlag$LAYOUT, SetVerboseFlag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static class AddToSystemClassLoaderSearch {

        AddToSystemClassLoaderSearch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(AddToSystemClassLoaderSearch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddToSystemClassLoaderSearch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddToSystemClassLoaderSearch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddToSystemClassLoaderSearch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static final AddressLayout AddToSystemClassLoaderSearch$layout() {
        return AddToSystemClassLoaderSearch$LAYOUT;
    }

    private static final long AddToSystemClassLoaderSearch$OFFSET = 1200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static final long AddToSystemClassLoaderSearch$offset() {
        return AddToSystemClassLoaderSearch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static MemorySegment AddToSystemClassLoaderSearch(MemorySegment struct) {
        return struct.get(AddToSystemClassLoaderSearch$LAYOUT, AddToSystemClassLoaderSearch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *)
     * }
     */
    public static void AddToSystemClassLoaderSearch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddToSystemClassLoaderSearch$LAYOUT, AddToSystemClassLoaderSearch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *)
     * }
     */
    public static class RetransformClasses {

        RetransformClasses() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(RetransformClasses.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RetransformClasses.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RetransformClasses$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RetransformClasses"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *)
     * }
     */
    public static final AddressLayout RetransformClasses$layout() {
        return RetransformClasses$LAYOUT;
    }

    private static final long RetransformClasses$OFFSET = 1208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *)
     * }
     */
    public static final long RetransformClasses$offset() {
        return RetransformClasses$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *)
     * }
     */
    public static MemorySegment RetransformClasses(MemorySegment struct) {
        return struct.get(RetransformClasses$LAYOUT, RetransformClasses$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *)
     * }
     */
    public static void RetransformClasses(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RetransformClasses$LAYOUT, RetransformClasses$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **)
     * }
     */
    public static class GetOwnedMonitorStackDepthInfo {

        GetOwnedMonitorStackDepthInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetOwnedMonitorStackDepthInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOwnedMonitorStackDepthInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOwnedMonitorStackDepthInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOwnedMonitorStackDepthInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **)
     * }
     */
    public static final AddressLayout GetOwnedMonitorStackDepthInfo$layout() {
        return GetOwnedMonitorStackDepthInfo$LAYOUT;
    }

    private static final long GetOwnedMonitorStackDepthInfo$OFFSET = 1216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **)
     * }
     */
    public static final long GetOwnedMonitorStackDepthInfo$offset() {
        return GetOwnedMonitorStackDepthInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **)
     * }
     */
    public static MemorySegment GetOwnedMonitorStackDepthInfo(MemorySegment struct) {
        return struct.get(GetOwnedMonitorStackDepthInfo$LAYOUT, GetOwnedMonitorStackDepthInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **)
     * }
     */
    public static void GetOwnedMonitorStackDepthInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOwnedMonitorStackDepthInfo$LAYOUT, GetOwnedMonitorStackDepthInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static class GetObjectSize {

        GetObjectSize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetObjectSize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectSize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectSize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static final AddressLayout GetObjectSize$layout() {
        return GetObjectSize$LAYOUT;
    }

    private static final long GetObjectSize$OFFSET = 1224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static final long GetObjectSize$offset() {
        return GetObjectSize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static MemorySegment GetObjectSize(MemorySegment struct) {
        return struct.get(GetObjectSize$LAYOUT, GetObjectSize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *)
     * }
     */
    public static void GetObjectSize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectSize$LAYOUT, GetObjectSize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *)
     * }
     */
    public static class GetLocalInstance {

        GetLocalInstance() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(GetLocalInstance.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLocalInstance.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLocalInstance$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLocalInstance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *)
     * }
     */
    public static final AddressLayout GetLocalInstance$layout() {
        return GetLocalInstance$LAYOUT;
    }

    private static final long GetLocalInstance$OFFSET = 1232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *)
     * }
     */
    public static final long GetLocalInstance$offset() {
        return GetLocalInstance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *)
     * }
     */
    public static MemorySegment GetLocalInstance(MemorySegment struct) {
        return struct.get(GetLocalInstance$LAYOUT, GetLocalInstance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *)
     * }
     */
    public static void GetLocalInstance(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLocalInstance$LAYOUT, GetLocalInstance$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint)
     * }
     */
    public static class SetHeapSamplingInterval {

        SetHeapSamplingInterval() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = jvmti_h.upcallHandle(SetHeapSamplingInterval.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetHeapSamplingInterval.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetHeapSamplingInterval$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetHeapSamplingInterval"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint)
     * }
     */
    public static final AddressLayout SetHeapSamplingInterval$layout() {
        return SetHeapSamplingInterval$LAYOUT;
    }

    private static final long SetHeapSamplingInterval$OFFSET = 1240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint)
     * }
     */
    public static final long SetHeapSamplingInterval$offset() {
        return SetHeapSamplingInterval$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint)
     * }
     */
    public static MemorySegment SetHeapSamplingInterval(MemorySegment struct) {
        return struct.get(SetHeapSamplingInterval$LAYOUT, SetHeapSamplingInterval$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint)
     * }
     */
    public static void SetHeapSamplingInterval(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetHeapSamplingInterval$LAYOUT, SetHeapSamplingInterval$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

