// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

public class jvmti_h {

    jvmti_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int __USE_ANSI = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ANSI 1
     * }
     */
    public static int __USE_ANSI() {
        return __USE_ANSI;
    }
    private static final int _BSD_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BSD_SOURCE 1
     * }
     */
    public static int _BSD_SOURCE() {
        return _BSD_SOURCE;
    }
    private static final int _SVID_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SVID_SOURCE 1
     * }
     */
    public static int _SVID_SOURCE() {
        return _SVID_SOURCE;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_BSD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_BSD 1
     * }
     */
    public static int __USE_BSD() {
        return __USE_BSD;
    }
    private static final int __USE_SVID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_SVID 1
     * }
     */
    public static int __USE_SVID() {
        return __USE_SVID;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __STDC_NO_THREADS__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_NO_THREADS__ 1
     * }
     */
    public static int __STDC_NO_THREADS__() {
        return __STDC_NO_THREADS__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)17L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 17
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int __GLIBC_HAVE_LONG_LONG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_HAVE_LONG_LONG 1
     * }
     */
    public static int __GLIBC_HAVE_LONG_LONG() {
        return __GLIBC_HAVE_LONG_LONG;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int _G_config_h = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _G_config_h 1
     * }
     */
    public static int _G_config_h() {
        return _G_config_h;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _G_HAVE_MMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _G_HAVE_MMAP 1
     * }
     */
    public static int _G_HAVE_MMAP() {
        return _G_HAVE_MMAP;
    }
    private static final int _G_HAVE_MREMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _G_HAVE_MREMAP 1
     * }
     */
    public static int _G_HAVE_MREMAP() {
        return _G_HAVE_MREMAP;
    }
    private static final int _G_IO_IO_FILE_VERSION = (int)131073L;
    /**
     * {@snippet lang=c :
     * #define _G_IO_IO_FILE_VERSION 131073
     * }
     */
    public static int _G_IO_IO_FILE_VERSION() {
        return _G_IO_IO_FILE_VERSION;
    }
    private static final int _G_BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _G_BUFSIZ 8192
     * }
     */
    public static int _G_BUFSIZ() {
        return _G_BUFSIZ;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _IO_UNIFIED_JUMPTABLES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IO_UNIFIED_JUMPTABLES 1
     * }
     */
    public static int _IO_UNIFIED_JUMPTABLES() {
        return _IO_UNIFIED_JUMPTABLES;
    }
    private static final int _IOS_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOS_INPUT 1
     * }
     */
    public static int _IOS_INPUT() {
        return _IOS_INPUT;
    }
    private static final int _IOS_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IOS_OUTPUT 2
     * }
     */
    public static int _IOS_OUTPUT() {
        return _IOS_OUTPUT;
    }
    private static final int _IOS_ATEND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IOS_ATEND 4
     * }
     */
    public static int _IOS_ATEND() {
        return _IOS_ATEND;
    }
    private static final int _IOS_APPEND = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _IOS_APPEND 8
     * }
     */
    public static int _IOS_APPEND() {
        return _IOS_APPEND;
    }
    private static final int _IOS_TRUNC = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IOS_TRUNC 16
     * }
     */
    public static int _IOS_TRUNC() {
        return _IOS_TRUNC;
    }
    private static final int _IOS_NOCREATE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IOS_NOCREATE 32
     * }
     */
    public static int _IOS_NOCREATE() {
        return _IOS_NOCREATE;
    }
    private static final int _IOS_NOREPLACE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOS_NOREPLACE 64
     * }
     */
    public static int _IOS_NOREPLACE() {
        return _IOS_NOREPLACE;
    }
    private static final int _IOS_BIN = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _IOS_BIN 128
     * }
     */
    public static int _IOS_BIN() {
        return _IOS_BIN;
    }
    private static final int _IO_USER_BUF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_BUF 1
     * }
     */
    public static int _IO_USER_BUF() {
        return _IO_USER_BUF;
    }
    private static final int _IO_UNBUFFERED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IO_UNBUFFERED 2
     * }
     */
    public static int _IO_UNBUFFERED() {
        return _IO_UNBUFFERED;
    }
    private static final int _IO_NO_READS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IO_NO_READS 4
     * }
     */
    public static int _IO_NO_READS() {
        return _IO_NO_READS;
    }
    private static final int _IO_NO_WRITES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _IO_NO_WRITES 8
     * }
     */
    public static int _IO_NO_WRITES() {
        return _IO_NO_WRITES;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_DELETE_DONT_CLOSE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IO_DELETE_DONT_CLOSE 64
     * }
     */
    public static int _IO_DELETE_DONT_CLOSE() {
        return _IO_DELETE_DONT_CLOSE;
    }
    private static final int _IO_LINKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _IO_LINKED 128
     * }
     */
    public static int _IO_LINKED() {
        return _IO_LINKED;
    }
    private static final int _IO_IN_BACKUP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _IO_IN_BACKUP 256
     * }
     */
    public static int _IO_IN_BACKUP() {
        return _IO_IN_BACKUP;
    }
    private static final int _IO_LINE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _IO_LINE_BUF 512
     * }
     */
    public static int _IO_LINE_BUF() {
        return _IO_LINE_BUF;
    }
    private static final int _IO_TIED_PUT_GET = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _IO_TIED_PUT_GET 1024
     * }
     */
    public static int _IO_TIED_PUT_GET() {
        return _IO_TIED_PUT_GET;
    }
    private static final int _IO_CURRENTLY_PUTTING = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _IO_CURRENTLY_PUTTING 2048
     * }
     */
    public static int _IO_CURRENTLY_PUTTING() {
        return _IO_CURRENTLY_PUTTING;
    }
    private static final int _IO_IS_APPENDING = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _IO_IS_APPENDING 4096
     * }
     */
    public static int _IO_IS_APPENDING() {
        return _IO_IS_APPENDING;
    }
    private static final int _IO_IS_FILEBUF = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _IO_IS_FILEBUF 8192
     * }
     */
    public static int _IO_IS_FILEBUF() {
        return _IO_IS_FILEBUF;
    }
    private static final int _IO_BAD_SEEN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _IO_BAD_SEEN 16384
     * }
     */
    public static int _IO_BAD_SEEN() {
        return _IO_BAD_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IO_FLAGS2_MMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IO_FLAGS2_MMAP 1
     * }
     */
    public static int _IO_FLAGS2_MMAP() {
        return _IO_FLAGS2_MMAP;
    }
    private static final int _IO_FLAGS2_NOTCANCEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IO_FLAGS2_NOTCANCEL 2
     * }
     */
    public static int _IO_FLAGS2_NOTCANCEL() {
        return _IO_FLAGS2_NOTCANCEL;
    }
    private static final int _IO_FLAGS2_USER_WBUF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _IO_FLAGS2_USER_WBUF 8
     * }
     */
    public static int _IO_FLAGS2_USER_WBUF() {
        return _IO_FLAGS2_USER_WBUF;
    }
    private static final int _IO_SKIPWS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IO_SKIPWS 1
     * }
     */
    public static int _IO_SKIPWS() {
        return _IO_SKIPWS;
    }
    private static final int _IO_LEFT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IO_LEFT 2
     * }
     */
    public static int _IO_LEFT() {
        return _IO_LEFT;
    }
    private static final int _IO_RIGHT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IO_RIGHT 4
     * }
     */
    public static int _IO_RIGHT() {
        return _IO_RIGHT;
    }
    private static final int _IO_INTERNAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _IO_INTERNAL 8
     * }
     */
    public static int _IO_INTERNAL() {
        return _IO_INTERNAL;
    }
    private static final int _IO_DEC = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_DEC 16
     * }
     */
    public static int _IO_DEC() {
        return _IO_DEC;
    }
    private static final int _IO_OCT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_OCT 32
     * }
     */
    public static int _IO_OCT() {
        return _IO_OCT;
    }
    private static final int _IO_HEX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IO_HEX 64
     * }
     */
    public static int _IO_HEX() {
        return _IO_HEX;
    }
    private static final int _IO_SHOWBASE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _IO_SHOWBASE 128
     * }
     */
    public static int _IO_SHOWBASE() {
        return _IO_SHOWBASE;
    }
    private static final int _IO_SHOWPOINT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _IO_SHOWPOINT 256
     * }
     */
    public static int _IO_SHOWPOINT() {
        return _IO_SHOWPOINT;
    }
    private static final int _IO_UPPERCASE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _IO_UPPERCASE 512
     * }
     */
    public static int _IO_UPPERCASE() {
        return _IO_UPPERCASE;
    }
    private static final int _IO_SHOWPOS = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _IO_SHOWPOS 1024
     * }
     */
    public static int _IO_SHOWPOS() {
        return _IO_SHOWPOS;
    }
    private static final int _IO_SCIENTIFIC = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _IO_SCIENTIFIC 2048
     * }
     */
    public static int _IO_SCIENTIFIC() {
        return _IO_SCIENTIFIC;
    }
    private static final int _IO_FIXED = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _IO_FIXED 4096
     * }
     */
    public static int _IO_FIXED() {
        return _IO_FIXED;
    }
    private static final int _IO_UNITBUF = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _IO_UNITBUF 8192
     * }
     */
    public static int _IO_UNITBUF() {
        return _IO_UNITBUF;
    }
    private static final int _IO_STDIO = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _IO_STDIO 16384
     * }
     */
    public static int _IO_STDIO() {
        return _IO_STDIO;
    }
    private static final int _IO_DONT_CLOSE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_DONT_CLOSE 32768
     * }
     */
    public static int _IO_DONT_CLOSE() {
        return _IO_DONT_CLOSE;
    }
    private static final int _IO_BOOLALPHA = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _IO_BOOLALPHA 65536
     * }
     */
    public static int _IO_BOOLALPHA() {
        return _IO_BOOLALPHA;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int JNI_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define JNI_FALSE 0
     * }
     */
    public static int JNI_FALSE() {
        return JNI_FALSE;
    }
    private static final int JNI_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define JNI_TRUE 1
     * }
     */
    public static int JNI_TRUE() {
        return JNI_TRUE;
    }
    private static final int JNI_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define JNI_OK 0
     * }
     */
    public static int JNI_OK() {
        return JNI_OK;
    }
    private static final int JNI_COMMIT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define JNI_COMMIT 1
     * }
     */
    public static int JNI_COMMIT() {
        return JNI_COMMIT;
    }
    private static final int JNI_ABORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define JNI_ABORT 2
     * }
     */
    public static int JNI_ABORT() {
        return JNI_ABORT;
    }
    private static final int JNI_VERSION_1_1 = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_1_1 65537
     * }
     */
    public static int JNI_VERSION_1_1() {
        return JNI_VERSION_1_1;
    }
    private static final int JNI_VERSION_1_2 = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_1_2 65538
     * }
     */
    public static int JNI_VERSION_1_2() {
        return JNI_VERSION_1_2;
    }
    private static final int JNI_VERSION_1_4 = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_1_4 65540
     * }
     */
    public static int JNI_VERSION_1_4() {
        return JNI_VERSION_1_4;
    }
    private static final int JNI_VERSION_1_6 = (int)65542L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_1_6 65542
     * }
     */
    public static int JNI_VERSION_1_6() {
        return JNI_VERSION_1_6;
    }
    private static final int JNI_VERSION_1_8 = (int)65544L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_1_8 65544
     * }
     */
    public static int JNI_VERSION_1_8() {
        return JNI_VERSION_1_8;
    }
    private static final int JNI_VERSION_9 = (int)589824L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_9 589824
     * }
     */
    public static int JNI_VERSION_9() {
        return JNI_VERSION_9;
    }
    private static final int JNI_VERSION_10 = (int)655360L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_10 655360
     * }
     */
    public static int JNI_VERSION_10() {
        return JNI_VERSION_10;
    }
    private static final int JNI_VERSION_19 = (int)1245184L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_19 1245184
     * }
     */
    public static int JNI_VERSION_19() {
        return JNI_VERSION_19;
    }
    private static final int JNI_VERSION_20 = (int)1310720L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_20 1310720
     * }
     */
    public static int JNI_VERSION_20() {
        return JNI_VERSION_20;
    }
    private static final int JNI_VERSION_21 = (int)1376256L;
    /**
     * {@snippet lang=c :
     * #define JNI_VERSION_21 1376256
     * }
     */
    public static int JNI_VERSION_21() {
        return JNI_VERSION_21;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = jvmti_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = jvmti_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = jvmti_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = jvmti_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = jvmti_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = jvmti_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t *__qaddr_t
     * }
     */
    public static final AddressLayout __qaddr_t = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = jvmti_h.C_INT;
    private static final int __codecvt_ok = (int)0L;
    /**
     * {@snippet lang=c :
     * enum __codecvt_result.__codecvt_ok = 0
     * }
     */
    public static int __codecvt_ok() {
        return __codecvt_ok;
    }
    private static final int __codecvt_partial = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __codecvt_result.__codecvt_partial = 1
     * }
     */
    public static int __codecvt_partial() {
        return __codecvt_partial;
    }
    private static final int __codecvt_error = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __codecvt_result.__codecvt_error = 2
     * }
     */
    public static int __codecvt_error() {
        return __codecvt_error;
    }
    private static final int __codecvt_noconv = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __codecvt_result.__codecvt_noconv = 3
     * }
     */
    public static int __codecvt_noconv() {
        return __codecvt_noconv;
    }

    private static class __underflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("__underflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __underflow(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor __underflow$descriptor() {
        return __underflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __underflow(_IO_FILE *)
     * }
     */
    public static MethodHandle __underflow$handle() {
        return __underflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __underflow(_IO_FILE *)
     * }
     */
    public static MemorySegment __underflow$address() {
        return __underflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __underflow(_IO_FILE *)
     * }
     */
    public static int __underflow(MemorySegment x0) {
        var mh$ = __underflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__underflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(_IO_FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(_IO_FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(_IO_FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(_IO_FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(_IO_FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(_IO_FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(_IO_FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_getc(_IO_FILE *__fp)
     * }
     */
    public static FunctionDescriptor _IO_getc$descriptor() {
        return _IO_getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_getc(_IO_FILE *__fp)
     * }
     */
    public static MethodHandle _IO_getc$handle() {
        return _IO_getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_getc(_IO_FILE *__fp)
     * }
     */
    public static MemorySegment _IO_getc$address() {
        return _IO_getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_getc(_IO_FILE *__fp)
     * }
     */
    public static int _IO_getc(MemorySegment __fp) {
        var mh$ = _IO_getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_getc", __fp);
            }
            return (int)mh$.invokeExact(__fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_putc(int __c, _IO_FILE *__fp)
     * }
     */
    public static FunctionDescriptor _IO_putc$descriptor() {
        return _IO_putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_putc(int __c, _IO_FILE *__fp)
     * }
     */
    public static MethodHandle _IO_putc$handle() {
        return _IO_putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_putc(int __c, _IO_FILE *__fp)
     * }
     */
    public static MemorySegment _IO_putc$address() {
        return _IO_putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_putc(int __c, _IO_FILE *__fp)
     * }
     */
    public static int _IO_putc(int __c, MemorySegment __fp) {
        var mh$ = _IO_putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_putc", __c, __fp);
            }
            return (int)mh$.invokeExact(__c, __fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_feof(_IO_FILE *__fp)
     * }
     */
    public static FunctionDescriptor _IO_feof$descriptor() {
        return _IO_feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_feof(_IO_FILE *__fp)
     * }
     */
    public static MethodHandle _IO_feof$handle() {
        return _IO_feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_feof(_IO_FILE *__fp)
     * }
     */
    public static MemorySegment _IO_feof$address() {
        return _IO_feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_feof(_IO_FILE *__fp)
     * }
     */
    public static int _IO_feof(MemorySegment __fp) {
        var mh$ = _IO_feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_feof", __fp);
            }
            return (int)mh$.invokeExact(__fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_ferror(_IO_FILE *__fp)
     * }
     */
    public static FunctionDescriptor _IO_ferror$descriptor() {
        return _IO_ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_ferror(_IO_FILE *__fp)
     * }
     */
    public static MethodHandle _IO_ferror$handle() {
        return _IO_ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_ferror(_IO_FILE *__fp)
     * }
     */
    public static MemorySegment _IO_ferror$address() {
        return _IO_ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_ferror(_IO_FILE *__fp)
     * }
     */
    public static int _IO_ferror(MemorySegment __fp) {
        var mh$ = _IO_ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_ferror", __fp);
            }
            return (int)mh$.invokeExact(__fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_peekc_locked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_peekc_locked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_peekc_locked(_IO_FILE *__fp)
     * }
     */
    public static FunctionDescriptor _IO_peekc_locked$descriptor() {
        return _IO_peekc_locked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_peekc_locked(_IO_FILE *__fp)
     * }
     */
    public static MethodHandle _IO_peekc_locked$handle() {
        return _IO_peekc_locked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_peekc_locked(_IO_FILE *__fp)
     * }
     */
    public static MemorySegment _IO_peekc_locked$address() {
        return _IO_peekc_locked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_peekc_locked(_IO_FILE *__fp)
     * }
     */
    public static int _IO_peekc_locked(MemorySegment __fp) {
        var mh$ = _IO_peekc_locked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_peekc_locked", __fp);
            }
            return (int)mh$.invokeExact(__fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _IO_flockfile(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor _IO_flockfile$descriptor() {
        return _IO_flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _IO_flockfile(_IO_FILE *)
     * }
     */
    public static MethodHandle _IO_flockfile$handle() {
        return _IO_flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _IO_flockfile(_IO_FILE *)
     * }
     */
    public static MemorySegment _IO_flockfile$address() {
        return _IO_flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _IO_flockfile(_IO_FILE *)
     * }
     */
    public static void _IO_flockfile(MemorySegment x0) {
        var mh$ = _IO_flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _IO_funlockfile(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor _IO_funlockfile$descriptor() {
        return _IO_funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _IO_funlockfile(_IO_FILE *)
     * }
     */
    public static MethodHandle _IO_funlockfile$handle() {
        return _IO_funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _IO_funlockfile(_IO_FILE *)
     * }
     */
    public static MemorySegment _IO_funlockfile$address() {
        return _IO_funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _IO_funlockfile(_IO_FILE *)
     * }
     */
    public static void _IO_funlockfile(MemorySegment x0) {
        var mh$ = _IO_funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_ftrylockfile(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor _IO_ftrylockfile$descriptor() {
        return _IO_ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_ftrylockfile(_IO_FILE *)
     * }
     */
    public static MethodHandle _IO_ftrylockfile$handle() {
        return _IO_ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_ftrylockfile(_IO_FILE *)
     * }
     */
    public static MemorySegment _IO_ftrylockfile$address() {
        return _IO_ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_ftrylockfile(_IO_FILE *)
     * }
     */
    public static int _IO_ftrylockfile(MemorySegment x0) {
        var mh$ = _IO_ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_vfscanf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list, int *restrict)
     * }
     */
    public static FunctionDescriptor _IO_vfscanf$descriptor() {
        return _IO_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_vfscanf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list, int *restrict)
     * }
     */
    public static MethodHandle _IO_vfscanf$handle() {
        return _IO_vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_vfscanf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list, int *restrict)
     * }
     */
    public static MemorySegment _IO_vfscanf$address() {
        return _IO_vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_vfscanf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list, int *restrict)
     * }
     */
    public static int _IO_vfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _IO_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_vfscanf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _IO_vfprintf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list)
     * }
     */
    public static FunctionDescriptor _IO_vfprintf$descriptor() {
        return _IO_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _IO_vfprintf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list)
     * }
     */
    public static MethodHandle _IO_vfprintf$handle() {
        return _IO_vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _IO_vfprintf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list)
     * }
     */
    public static MemorySegment _IO_vfprintf$address() {
        return _IO_vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _IO_vfprintf(_IO_FILE *restrict, const char *restrict, __gnuc_va_list)
     * }
     */
    public static int _IO_vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _IO_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_padn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_LONG
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_padn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t)
     * }
     */
    public static FunctionDescriptor _IO_padn$descriptor() {
        return _IO_padn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t)
     * }
     */
    public static MethodHandle _IO_padn$handle() {
        return _IO_padn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t)
     * }
     */
    public static MemorySegment _IO_padn$address() {
        return _IO_padn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t)
     * }
     */
    public static long _IO_padn(MemorySegment x0, int x1, long x2) {
        var mh$ = _IO_padn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_padn", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_sgetn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_sgetn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t _IO_sgetn(_IO_FILE *, void *, size_t)
     * }
     */
    public static FunctionDescriptor _IO_sgetn$descriptor() {
        return _IO_sgetn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t _IO_sgetn(_IO_FILE *, void *, size_t)
     * }
     */
    public static MethodHandle _IO_sgetn$handle() {
        return _IO_sgetn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t _IO_sgetn(_IO_FILE *, void *, size_t)
     * }
     */
    public static MemorySegment _IO_sgetn$address() {
        return _IO_sgetn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t _IO_sgetn(_IO_FILE *, void *, size_t)
     * }
     */
    public static long _IO_sgetn(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = _IO_sgetn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_sgetn", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_seekoff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_INT,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_seekoff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int)
     * }
     */
    public static FunctionDescriptor _IO_seekoff$descriptor() {
        return _IO_seekoff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int)
     * }
     */
    public static MethodHandle _IO_seekoff$handle() {
        return _IO_seekoff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int)
     * }
     */
    public static MemorySegment _IO_seekoff$address() {
        return _IO_seekoff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int)
     * }
     */
    public static long _IO_seekoff(MemorySegment x0, long x1, int x2, int x3) {
        var mh$ = _IO_seekoff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_seekoff", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_seekpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_seekpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int)
     * }
     */
    public static FunctionDescriptor _IO_seekpos$descriptor() {
        return _IO_seekpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int)
     * }
     */
    public static MethodHandle _IO_seekpos$handle() {
        return _IO_seekpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int)
     * }
     */
    public static MemorySegment _IO_seekpos$address() {
        return _IO_seekpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int)
     * }
     */
    public static long _IO_seekpos(MemorySegment x0, long x1, int x2) {
        var mh$ = _IO_seekpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_seekpos", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _IO_free_backup_area {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("_IO_free_backup_area");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _IO_free_backup_area(_IO_FILE *)
     * }
     */
    public static FunctionDescriptor _IO_free_backup_area$descriptor() {
        return _IO_free_backup_area.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _IO_free_backup_area(_IO_FILE *)
     * }
     */
    public static MethodHandle _IO_free_backup_area$handle() {
        return _IO_free_backup_area.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _IO_free_backup_area(_IO_FILE *)
     * }
     */
    public static MemorySegment _IO_free_backup_area$address() {
        return _IO_free_backup_area.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _IO_free_backup_area(_IO_FILE *)
     * }
     */
    public static void _IO_free_backup_area(MemorySegment x0) {
        var mh$ = _IO_free_backup_area.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_IO_free_backup_area", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = jvmti_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = jvmti_h.C_POINTER;
        public static final MemorySegment SEGMENT = jvmti_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = jvmti_h.C_POINTER;
        public static final MemorySegment SEGMENT = jvmti_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = jvmti_h.C_POINTER;
        public static final MemorySegment SEGMENT = jvmti_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _IO_FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER    );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char *__s)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char *__s)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char *__s)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char *__s)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment __s) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char *__s)
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char *__s)
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char *__s)
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char *__s)
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_LONG
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER,
                jvmti_h.C_LONG,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_INT,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                jvmti_h.C_INT,
                jvmti_h.C_POINTER,
                jvmti_h.C_POINTER
            );
        private static final MemorySegment ADDR = jvmti_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT    );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT    );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_LONG,
            jvmti_h.C_INT
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_LONG,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = jvmti_h.C_INT;
        public static final MemorySegment SEGMENT = jvmti_h.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, jvmti_h.C_POINTER);
        public static final MemorySegment SEGMENT = jvmti_h.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int jint
     * }
     */
    public static final OfInt jint = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long jlong
     * }
     */
    public static final OfLong jlong = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char jbyte
     * }
     */
    public static final OfByte jbyte = jvmti_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char jboolean
     * }
     */
    public static final OfByte jboolean = jvmti_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short jchar
     * }
     */
    public static final OfShort jchar = jvmti_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef short jshort
     * }
     */
    public static final OfShort jshort = jvmti_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef float jfloat
     * }
     */
    public static final OfFloat jfloat = jvmti_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double jdouble
     * }
     */
    public static final OfDouble jdouble = jvmti_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef jint jsize
     * }
     */
    public static final OfInt jsize = jvmti_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct _jobject *jobject
     * }
     */
    public static final AddressLayout jobject = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jclass
     * }
     */
    public static final AddressLayout jclass = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jthrowable
     * }
     */
    public static final AddressLayout jthrowable = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jstring
     * }
     */
    public static final AddressLayout jstring = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jarray
     * }
     */
    public static final AddressLayout jarray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jbooleanArray
     * }
     */
    public static final AddressLayout jbooleanArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jbyteArray
     * }
     */
    public static final AddressLayout jbyteArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jcharArray
     * }
     */
    public static final AddressLayout jcharArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jshortArray
     * }
     */
    public static final AddressLayout jshortArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jintArray
     * }
     */
    public static final AddressLayout jintArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jlongArray
     * }
     */
    public static final AddressLayout jlongArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jfloatArray
     * }
     */
    public static final AddressLayout jfloatArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jdoubleArray
     * }
     */
    public static final AddressLayout jdoubleArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jarray jobjectArray
     * }
     */
    public static final AddressLayout jobjectArray = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jweak
     * }
     */
    public static final AddressLayout jweak = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _jfieldID *jfieldID
     * }
     */
    public static final AddressLayout jfieldID = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _jmethodID *jmethodID
     * }
     */
    public static final AddressLayout jmethodID = jvmti_h.C_POINTER;
    private static final int JNIInvalidRefType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _jobjectType.JNIInvalidRefType = 0
     * }
     */
    public static int JNIInvalidRefType() {
        return JNIInvalidRefType;
    }
    private static final int JNILocalRefType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _jobjectType.JNILocalRefType = 1
     * }
     */
    public static int JNILocalRefType() {
        return JNILocalRefType;
    }
    private static final int JNIGlobalRefType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _jobjectType.JNIGlobalRefType = 2
     * }
     */
    public static int JNIGlobalRefType() {
        return JNIGlobalRefType;
    }
    private static final int JNIWeakGlobalRefType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _jobjectType.JNIWeakGlobalRefType = 3
     * }
     */
    public static int JNIWeakGlobalRefType() {
        return JNIWeakGlobalRefType;
    }
    /**
     * {@snippet lang=c :
     * typedef const struct JNINativeInterface_ {
     *     void *reserved0;
     *     void *reserved1;
     *     void *reserved2;
     *     void *reserved3;
     *     jint (*GetVersion)(JNIEnv *);
     *     jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize);
     *     jclass (*FindClass)(JNIEnv *, const char *);
     *     jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);
     *     jfieldID (*FromReflectedField)(JNIEnv *, jobject);
     *     jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);
     *     jclass (*GetSuperclass)(JNIEnv *, jclass);
     *     jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);
     *     jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);
     *     jint (*Throw)(JNIEnv *, jthrowable);
     *     jint (*ThrowNew)(JNIEnv *, jclass, const char *);
     *     jthrowable (*ExceptionOccurred)(JNIEnv *);
     *     void (*ExceptionDescribe)(JNIEnv *);
     *     void (*ExceptionClear)(JNIEnv *);
     *     void (*FatalError)(JNIEnv *, const char *);
     *     jint (*PushLocalFrame)(JNIEnv *, jint);
     *     jobject (*PopLocalFrame)(JNIEnv *, jobject);
     *     jobject (*NewGlobalRef)(JNIEnv *, jobject);
     *     void (*DeleteGlobalRef)(JNIEnv *, jobject);
     *     void (*DeleteLocalRef)(JNIEnv *, jobject);
     *     jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);
     *     jobject (*NewLocalRef)(JNIEnv *, jobject);
     *     jint (*EnsureLocalCapacity)(JNIEnv *, jint);
     *     jobject (*AllocObject)(JNIEnv *, jclass);
     *     jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);
     *     jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jclass (*GetObjectClass)(JNIEnv *, jobject);
     *     jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);
     *     jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *);
     *     jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     void (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);
     *     void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, __va_list_tag *);
     *     void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
     *     jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     void (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
     *     void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, __va_list_tag *);
     *     void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
     *     jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *);
     *     jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);
     *     jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);
     *     jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);
     *     jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);
     *     jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);
     *     jint (*GetIntField)(JNIEnv *, jobject, jfieldID);
     *     jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);
     *     jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);
     *     jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);
     *     void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);
     *     void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);
     *     void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);
     *     void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);
     *     void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);
     *     void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);
     *     void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);
     *     void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);
     *     void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);
     *     jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *);
     *     jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     void (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);
     *     void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, __va_list_tag *);
     *     void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
     *     jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *);
     *     jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);
     *     jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);
     *     jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);
     *     jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);
     *     jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);
     *     jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);
     *     jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);
     *     jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);
     *     jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);
     *     void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);
     *     void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);
     *     void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);
     *     void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);
     *     void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);
     *     void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);
     *     void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);
     *     void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);
     *     void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);
     *     jstring (*NewString)(JNIEnv *, const jchar *, jsize);
     *     jsize (*GetStringLength)(JNIEnv *, jstring);
     *     const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);
     *     void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *);
     *     jstring (*NewStringUTF)(JNIEnv *, const char *);
     *     jsize (*GetStringUTFLength)(JNIEnv *, jstring);
     *     const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);
     *     void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *);
     *     jsize (*GetArrayLength)(JNIEnv *, jarray);
     *     jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);
     *     jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);
     *     void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);
     *     jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);
     *     jbyteArray (*NewByteArray)(JNIEnv *, jsize);
     *     jcharArray (*NewCharArray)(JNIEnv *, jsize);
     *     jshortArray (*NewShortArray)(JNIEnv *, jsize);
     *     jintArray (*NewIntArray)(JNIEnv *, jsize);
     *     jlongArray (*NewLongArray)(JNIEnv *, jsize);
     *     jfloatArray (*NewFloatArray)(JNIEnv *, jsize);
     *     jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);
     *     jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);
     *     jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);
     *     jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);
     *     jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);
     *     jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);
     *     jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);
     *     jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);
     *     jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);
     *     void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);
     *     void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);
     *     void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);
     *     void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);
     *     void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);
     *     void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);
     *     void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);
     *     void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);
     *     void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);
     *     void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);
     *     void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);
     *     void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);
     *     void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);
     *     void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);
     *     void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);
     *     void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);
     *     void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *);
     *     void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *);
     *     void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *);
     *     void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *);
     *     void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *);
     *     void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *);
     *     void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *);
     *     void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *);
     *     jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint);
     *     jint (*UnregisterNatives)(JNIEnv *, jclass);
     *     jint (*MonitorEnter)(JNIEnv *, jobject);
     *     jint (*MonitorExit)(JNIEnv *, jobject);
     *     jint (*GetJavaVM)(JNIEnv *, JavaVM **);
     *     void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);
     *     void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *);
     *     void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);
     *     void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint);
     *     const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);
     *     void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *);
     *     jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);
     *     void (*DeleteWeakGlobalRef)(JNIEnv *, jweak);
     *     jboolean (*ExceptionCheck)(JNIEnv *);
     *     jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong);
     *     void *(*GetDirectBufferAddress)(JNIEnv *, jobject);
     *     jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);
     *     jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);
     *     jobject (*GetModule)(JNIEnv *, jclass);
     *     jboolean (*IsVirtualThread)(JNIEnv *, jobject);
     * } *JNIEnv
     * }
     */
    public static final AddressLayout JNIEnv = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct JNIInvokeInterface_ {
     *     void *reserved0;
     *     void *reserved1;
     *     void *reserved2;
     *     jint (*DestroyJavaVM)(JavaVM *);
     *     jint (*AttachCurrentThread)(JavaVM *, void **, void *);
     *     jint (*DetachCurrentThread)(JavaVM *);
     *     jint (*GetEnv)(JavaVM *, void **, jint);
     *     jint (*AttachCurrentThreadAsDaemon)(JavaVM *, void **, void *);
     * } *JavaVM
     * }
     */
    public static final AddressLayout JavaVM = jvmti_h.C_POINTER;

    private static class JNI_GetDefaultJavaVMInitArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("JNI_GetDefaultJavaVMInitArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint JNI_GetDefaultJavaVMInitArgs(void *args)
     * }
     */
    public static FunctionDescriptor JNI_GetDefaultJavaVMInitArgs$descriptor() {
        return JNI_GetDefaultJavaVMInitArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint JNI_GetDefaultJavaVMInitArgs(void *args)
     * }
     */
    public static MethodHandle JNI_GetDefaultJavaVMInitArgs$handle() {
        return JNI_GetDefaultJavaVMInitArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint JNI_GetDefaultJavaVMInitArgs(void *args)
     * }
     */
    public static MemorySegment JNI_GetDefaultJavaVMInitArgs$address() {
        return JNI_GetDefaultJavaVMInitArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint JNI_GetDefaultJavaVMInitArgs(void *args)
     * }
     */
    public static int JNI_GetDefaultJavaVMInitArgs(MemorySegment args) {
        var mh$ = JNI_GetDefaultJavaVMInitArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JNI_GetDefaultJavaVMInitArgs", args);
            }
            return (int)mh$.invokeExact(args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JNI_CreateJavaVM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("JNI_CreateJavaVM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args)
     * }
     */
    public static FunctionDescriptor JNI_CreateJavaVM$descriptor() {
        return JNI_CreateJavaVM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args)
     * }
     */
    public static MethodHandle JNI_CreateJavaVM$handle() {
        return JNI_CreateJavaVM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args)
     * }
     */
    public static MemorySegment JNI_CreateJavaVM$address() {
        return JNI_CreateJavaVM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args)
     * }
     */
    public static int JNI_CreateJavaVM(MemorySegment pvm, MemorySegment penv, MemorySegment args) {
        var mh$ = JNI_CreateJavaVM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JNI_CreateJavaVM", pvm, penv, args);
            }
            return (int)mh$.invokeExact(pvm, penv, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JNI_GetCreatedJavaVMs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_INT,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("JNI_GetCreatedJavaVMs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *)
     * }
     */
    public static FunctionDescriptor JNI_GetCreatedJavaVMs$descriptor() {
        return JNI_GetCreatedJavaVMs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *)
     * }
     */
    public static MethodHandle JNI_GetCreatedJavaVMs$handle() {
        return JNI_GetCreatedJavaVMs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *)
     * }
     */
    public static MemorySegment JNI_GetCreatedJavaVMs$address() {
        return JNI_GetCreatedJavaVMs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *)
     * }
     */
    public static int JNI_GetCreatedJavaVMs(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = JNI_GetCreatedJavaVMs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JNI_GetCreatedJavaVMs", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JNI_OnLoad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("JNI_OnLoad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint JNI_OnLoad(JavaVM *vm, void *reserved)
     * }
     */
    public static FunctionDescriptor JNI_OnLoad$descriptor() {
        return JNI_OnLoad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint JNI_OnLoad(JavaVM *vm, void *reserved)
     * }
     */
    public static MethodHandle JNI_OnLoad$handle() {
        return JNI_OnLoad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint JNI_OnLoad(JavaVM *vm, void *reserved)
     * }
     */
    public static MemorySegment JNI_OnLoad$address() {
        return JNI_OnLoad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint JNI_OnLoad(JavaVM *vm, void *reserved)
     * }
     */
    public static int JNI_OnLoad(MemorySegment vm, MemorySegment reserved) {
        var mh$ = JNI_OnLoad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JNI_OnLoad", vm, reserved);
            }
            return (int)mh$.invokeExact(vm, reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class JNI_OnUnload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("JNI_OnUnload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void JNI_OnUnload(JavaVM *vm, void *reserved)
     * }
     */
    public static FunctionDescriptor JNI_OnUnload$descriptor() {
        return JNI_OnUnload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void JNI_OnUnload(JavaVM *vm, void *reserved)
     * }
     */
    public static MethodHandle JNI_OnUnload$handle() {
        return JNI_OnUnload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void JNI_OnUnload(JavaVM *vm, void *reserved)
     * }
     */
    public static MemorySegment JNI_OnUnload$address() {
        return JNI_OnUnload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void JNI_OnUnload(JavaVM *vm, void *reserved)
     * }
     */
    public static void JNI_OnUnload(MemorySegment vm, MemorySegment reserved) {
        var mh$ = JNI_OnUnload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("JNI_OnUnload", vm, reserved);
            }
            mh$.invokeExact(vm, reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int JVMTI_VERSION_1 = (int)805371904L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_1 = 805371904
     * }
     */
    public static int JVMTI_VERSION_1() {
        return JVMTI_VERSION_1;
    }
    private static final int JVMTI_VERSION_1_0 = (int)805371904L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_1_0 = 805371904
     * }
     */
    public static int JVMTI_VERSION_1_0() {
        return JVMTI_VERSION_1_0;
    }
    private static final int JVMTI_VERSION_1_1 = (int)805372160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_1_1 = 805372160
     * }
     */
    public static int JVMTI_VERSION_1_1() {
        return JVMTI_VERSION_1_1;
    }
    private static final int JVMTI_VERSION_1_2 = (int)805372416L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_1_2 = 805372416
     * }
     */
    public static int JVMTI_VERSION_1_2() {
        return JVMTI_VERSION_1_2;
    }
    private static final int JVMTI_VERSION_9 = (int)805896192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_9 = 805896192
     * }
     */
    public static int JVMTI_VERSION_9() {
        return JVMTI_VERSION_9;
    }
    private static final int JVMTI_VERSION_11 = (int)806027264L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_11 = 806027264
     * }
     */
    public static int JVMTI_VERSION_11() {
        return JVMTI_VERSION_11;
    }
    private static final int JVMTI_VERSION_19 = (int)806551552L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_19 = 806551552
     * }
     */
    public static int JVMTI_VERSION_19() {
        return JVMTI_VERSION_19;
    }
    private static final int JVMTI_VERSION_21 = (int)806682624L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_21 = 806682624
     * }
     */
    public static int JVMTI_VERSION_21() {
        return JVMTI_VERSION_21;
    }
    private static final int JVMTI_VERSION = (int)806748160L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION = 806748160
     * }
     */
    public static int JVMTI_VERSION() {
        return JVMTI_VERSION;
    }

    private static class Agent_OnLoad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("Agent_OnLoad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static FunctionDescriptor Agent_OnLoad$descriptor() {
        return Agent_OnLoad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static MethodHandle Agent_OnLoad$handle() {
        return Agent_OnLoad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static MemorySegment Agent_OnLoad$address() {
        return Agent_OnLoad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static int Agent_OnLoad(MemorySegment vm, MemorySegment options, MemorySegment reserved) {
        var mh$ = Agent_OnLoad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Agent_OnLoad", vm, options, reserved);
            }
            return (int)mh$.invokeExact(vm, options, reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Agent_OnAttach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jvmti_h.C_INT,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER,
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("Agent_OnAttach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jint Agent_OnAttach(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static FunctionDescriptor Agent_OnAttach$descriptor() {
        return Agent_OnAttach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jint Agent_OnAttach(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static MethodHandle Agent_OnAttach$handle() {
        return Agent_OnAttach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jint Agent_OnAttach(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static MemorySegment Agent_OnAttach$address() {
        return Agent_OnAttach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jint Agent_OnAttach(JavaVM *vm, char *options, void *reserved)
     * }
     */
    public static int Agent_OnAttach(MemorySegment vm, MemorySegment options, MemorySegment reserved) {
        var mh$ = Agent_OnAttach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Agent_OnAttach", vm, options, reserved);
            }
            return (int)mh$.invokeExact(vm, options, reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Agent_OnUnload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            jvmti_h.C_POINTER
        );

        public static final MemorySegment ADDR = jvmti_h.findOrThrow("Agent_OnUnload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Agent_OnUnload(JavaVM *vm)
     * }
     */
    public static FunctionDescriptor Agent_OnUnload$descriptor() {
        return Agent_OnUnload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Agent_OnUnload(JavaVM *vm)
     * }
     */
    public static MethodHandle Agent_OnUnload$handle() {
        return Agent_OnUnload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Agent_OnUnload(JavaVM *vm)
     * }
     */
    public static MemorySegment Agent_OnUnload$address() {
        return Agent_OnUnload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Agent_OnUnload(JavaVM *vm)
     * }
     */
    public static void Agent_OnUnload(MemorySegment vm) {
        var mh$ = Agent_OnUnload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Agent_OnUnload", vm);
            }
            mh$.invokeExact(vm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef const struct jvmtiInterface_1_ {
     *     void *reserved1;
     *     jvmtiError (*SetEventNotificationMode)(jvmtiEnv *, jvmtiEventMode, jvmtiEvent, jthread, ...);
     *     jvmtiError (*GetAllModules)(jvmtiEnv *, jint *, jobject **);
     *     jvmtiError (*GetAllThreads)(jvmtiEnv *, jint *, jthread **);
     *     jvmtiError (*SuspendThread)(jvmtiEnv *, jthread);
     *     jvmtiError (*ResumeThread)(jvmtiEnv *, jthread);
     *     jvmtiError (*StopThread)(jvmtiEnv *, jthread, jobject);
     *     jvmtiError (*InterruptThread)(jvmtiEnv *, jthread);
     *     jvmtiError (*GetThreadInfo)(jvmtiEnv *, jthread, jvmtiThreadInfo *);
     *     jvmtiError (*GetOwnedMonitorInfo)(jvmtiEnv *, jthread, jint *, jobject **);
     *     jvmtiError (*GetCurrentContendedMonitor)(jvmtiEnv *, jthread, jobject *);
     *     jvmtiError (*RunAgentThread)(jvmtiEnv *, jthread, jvmtiStartFunction, const void *, jint);
     *     jvmtiError (*GetTopThreadGroups)(jvmtiEnv *, jint *, jthreadGroup **);
     *     jvmtiError (*GetThreadGroupInfo)(jvmtiEnv *, jthreadGroup, jvmtiThreadGroupInfo *);
     *     jvmtiError (*GetThreadGroupChildren)(jvmtiEnv *, jthreadGroup, jint *, jthread **, jint *, jthreadGroup **);
     *     jvmtiError (*GetFrameCount)(jvmtiEnv *, jthread, jint *);
     *     jvmtiError (*GetThreadState)(jvmtiEnv *, jthread, jint *);
     *     jvmtiError (*GetCurrentThread)(jvmtiEnv *, jthread *);
     *     jvmtiError (*GetFrameLocation)(jvmtiEnv *, jthread, jint, jmethodID *, jlocation *);
     *     jvmtiError (*NotifyFramePop)(jvmtiEnv *, jthread, jint);
     *     jvmtiError (*GetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject *);
     *     jvmtiError (*GetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint *);
     *     jvmtiError (*GetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong *);
     *     jvmtiError (*GetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat *);
     *     jvmtiError (*GetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble *);
     *     jvmtiError (*SetLocalObject)(jvmtiEnv *, jthread, jint, jint, jobject);
     *     jvmtiError (*SetLocalInt)(jvmtiEnv *, jthread, jint, jint, jint);
     *     jvmtiError (*SetLocalLong)(jvmtiEnv *, jthread, jint, jint, jlong);
     *     jvmtiError (*SetLocalFloat)(jvmtiEnv *, jthread, jint, jint, jfloat);
     *     jvmtiError (*SetLocalDouble)(jvmtiEnv *, jthread, jint, jint, jdouble);
     *     jvmtiError (*CreateRawMonitor)(jvmtiEnv *, const char *, jrawMonitorID *);
     *     jvmtiError (*DestroyRawMonitor)(jvmtiEnv *, jrawMonitorID);
     *     jvmtiError (*RawMonitorEnter)(jvmtiEnv *, jrawMonitorID);
     *     jvmtiError (*RawMonitorExit)(jvmtiEnv *, jrawMonitorID);
     *     jvmtiError (*RawMonitorWait)(jvmtiEnv *, jrawMonitorID, jlong);
     *     jvmtiError (*RawMonitorNotify)(jvmtiEnv *, jrawMonitorID);
     *     jvmtiError (*RawMonitorNotifyAll)(jvmtiEnv *, jrawMonitorID);
     *     jvmtiError (*SetBreakpoint)(jvmtiEnv *, jmethodID, jlocation);
     *     jvmtiError (*ClearBreakpoint)(jvmtiEnv *, jmethodID, jlocation);
     *     jvmtiError (*GetNamedModule)(jvmtiEnv *, jobject, const char *, jobject *);
     *     jvmtiError (*SetFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID);
     *     jvmtiError (*ClearFieldAccessWatch)(jvmtiEnv *, jclass, jfieldID);
     *     jvmtiError (*SetFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID);
     *     jvmtiError (*ClearFieldModificationWatch)(jvmtiEnv *, jclass, jfieldID);
     *     jvmtiError (*IsModifiableClass)(jvmtiEnv *, jclass, jboolean *);
     *     jvmtiError (*Allocate)(jvmtiEnv *, jlong, unsigned char **);
     *     jvmtiError (*Deallocate)(jvmtiEnv *, unsigned char *);
     *     jvmtiError (*GetClassSignature)(jvmtiEnv *, jclass, char **, char **);
     *     jvmtiError (*GetClassStatus)(jvmtiEnv *, jclass, jint *);
     *     jvmtiError (*GetSourceFileName)(jvmtiEnv *, jclass, char **);
     *     jvmtiError (*GetClassModifiers)(jvmtiEnv *, jclass, jint *);
     *     jvmtiError (*GetClassMethods)(jvmtiEnv *, jclass, jint *, jmethodID **);
     *     jvmtiError (*GetClassFields)(jvmtiEnv *, jclass, jint *, jfieldID **);
     *     jvmtiError (*GetImplementedInterfaces)(jvmtiEnv *, jclass, jint *, jclass **);
     *     jvmtiError (*IsInterface)(jvmtiEnv *, jclass, jboolean *);
     *     jvmtiError (*IsArrayClass)(jvmtiEnv *, jclass, jboolean *);
     *     jvmtiError (*GetClassLoader)(jvmtiEnv *, jclass, jobject *);
     *     jvmtiError (*GetObjectHashCode)(jvmtiEnv *, jobject, jint *);
     *     jvmtiError (*GetObjectMonitorUsage)(jvmtiEnv *, jobject, jvmtiMonitorUsage *);
     *     jvmtiError (*GetFieldName)(jvmtiEnv *, jclass, jfieldID, char **, char **, char **);
     *     jvmtiError (*GetFieldDeclaringClass)(jvmtiEnv *, jclass, jfieldID, jclass *);
     *     jvmtiError (*GetFieldModifiers)(jvmtiEnv *, jclass, jfieldID, jint *);
     *     jvmtiError (*IsFieldSynthetic)(jvmtiEnv *, jclass, jfieldID, jboolean *);
     *     jvmtiError (*GetMethodName)(jvmtiEnv *, jmethodID, char **, char **, char **);
     *     jvmtiError (*GetMethodDeclaringClass)(jvmtiEnv *, jmethodID, jclass *);
     *     jvmtiError (*GetMethodModifiers)(jvmtiEnv *, jmethodID, jint *);
     *     void *reserved67;
     *     jvmtiError (*GetMaxLocals)(jvmtiEnv *, jmethodID, jint *);
     *     jvmtiError (*GetArgumentsSize)(jvmtiEnv *, jmethodID, jint *);
     *     jvmtiError (*GetLineNumberTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLineNumberEntry **);
     *     jvmtiError (*GetMethodLocation)(jvmtiEnv *, jmethodID, jlocation *, jlocation *);
     *     jvmtiError (*GetLocalVariableTable)(jvmtiEnv *, jmethodID, jint *, jvmtiLocalVariableEntry **);
     *     jvmtiError (*SetNativeMethodPrefix)(jvmtiEnv *, const char *);
     *     jvmtiError (*SetNativeMethodPrefixes)(jvmtiEnv *, jint, char **);
     *     jvmtiError (*GetBytecodes)(jvmtiEnv *, jmethodID, jint *, unsigned char **);
     *     jvmtiError (*IsMethodNative)(jvmtiEnv *, jmethodID, jboolean *);
     *     jvmtiError (*IsMethodSynthetic)(jvmtiEnv *, jmethodID, jboolean *);
     *     jvmtiError (*GetLoadedClasses)(jvmtiEnv *, jint *, jclass **);
     *     jvmtiError (*GetClassLoaderClasses)(jvmtiEnv *, jobject, jint *, jclass **);
     *     jvmtiError (*PopFrame)(jvmtiEnv *, jthread);
     *     jvmtiError (*ForceEarlyReturnObject)(jvmtiEnv *, jthread, jobject);
     *     jvmtiError (*ForceEarlyReturnInt)(jvmtiEnv *, jthread, jint);
     *     jvmtiError (*ForceEarlyReturnLong)(jvmtiEnv *, jthread, jlong);
     *     jvmtiError (*ForceEarlyReturnFloat)(jvmtiEnv *, jthread, jfloat);
     *     jvmtiError (*ForceEarlyReturnDouble)(jvmtiEnv *, jthread, jdouble);
     *     jvmtiError (*ForceEarlyReturnVoid)(jvmtiEnv *, jthread);
     *     jvmtiError (*RedefineClasses)(jvmtiEnv *, jint, const jvmtiClassDefinition *);
     *     jvmtiError (*GetVersionNumber)(jvmtiEnv *, jint *);
     *     jvmtiError (*GetCapabilities)(jvmtiEnv *, jvmtiCapabilities *);
     *     jvmtiError (*GetSourceDebugExtension)(jvmtiEnv *, jclass, char **);
     *     jvmtiError (*IsMethodObsolete)(jvmtiEnv *, jmethodID, jboolean *);
     *     jvmtiError (*SuspendThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *);
     *     jvmtiError (*ResumeThreadList)(jvmtiEnv *, jint, const jthread *, jvmtiError *);
     *     jvmtiError (*AddModuleReads)(jvmtiEnv *, jobject, jobject);
     *     jvmtiError (*AddModuleExports)(jvmtiEnv *, jobject, const char *, jobject);
     *     jvmtiError (*AddModuleOpens)(jvmtiEnv *, jobject, const char *, jobject);
     *     jvmtiError (*AddModuleUses)(jvmtiEnv *, jobject, jclass);
     *     jvmtiError (*AddModuleProvides)(jvmtiEnv *, jobject, jclass, jclass);
     *     jvmtiError (*IsModifiableModule)(jvmtiEnv *, jobject, jboolean *);
     *     jvmtiError (*GetAllStackTraces)(jvmtiEnv *, jint, jvmtiStackInfo **, jint *);
     *     jvmtiError (*GetThreadListStackTraces)(jvmtiEnv *, jint, const jthread *, jint, jvmtiStackInfo **);
     *     jvmtiError (*GetThreadLocalStorage)(jvmtiEnv *, jthread, void **);
     *     jvmtiError (*SetThreadLocalStorage)(jvmtiEnv *, jthread, const void *);
     *     jvmtiError (*GetStackTrace)(jvmtiEnv *, jthread, jint, jint, jvmtiFrameInfo *, jint *);
     *     void *reserved105;
     *     jvmtiError (*GetTag)(jvmtiEnv *, jobject, jlong *);
     *     jvmtiError (*SetTag)(jvmtiEnv *, jobject, jlong);
     *     jvmtiError (*ForceGarbageCollection)(jvmtiEnv *);
     *     jvmtiError (*IterateOverObjectsReachableFromObject)(jvmtiEnv *, jobject, jvmtiObjectReferenceCallback, const void *);
     *     jvmtiError (*IterateOverReachableObjects)(jvmtiEnv *, jvmtiHeapRootCallback, jvmtiStackReferenceCallback, jvmtiObjectReferenceCallback, const void *);
     *     jvmtiError (*IterateOverHeap)(jvmtiEnv *, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *);
     *     jvmtiError (*IterateOverInstancesOfClass)(jvmtiEnv *, jclass, jvmtiHeapObjectFilter, jvmtiHeapObjectCallback, const void *);
     *     void *reserved113;
     *     jvmtiError (*GetObjectsWithTags)(jvmtiEnv *, jint, const jlong *, jint *, jobject **, jlong **);
     *     jvmtiError (*FollowReferences)(jvmtiEnv *, jint, jclass, jobject, const jvmtiHeapCallbacks *, const void *);
     *     jvmtiError (*IterateThroughHeap)(jvmtiEnv *, jint, jclass, const jvmtiHeapCallbacks *, const void *);
     *     void *reserved117;
     *     jvmtiError (*SuspendAllVirtualThreads)(jvmtiEnv *, jint, const jthread *);
     *     jvmtiError (*ResumeAllVirtualThreads)(jvmtiEnv *, jint, const jthread *);
     *     jvmtiError (*SetJNIFunctionTable)(jvmtiEnv *, const jniNativeInterface *);
     *     jvmtiError (*GetJNIFunctionTable)(jvmtiEnv *, jniNativeInterface **);
     *     jvmtiError (*SetEventCallbacks)(jvmtiEnv *, const jvmtiEventCallbacks *, jint);
     *     jvmtiError (*GenerateEvents)(jvmtiEnv *, jvmtiEvent);
     *     jvmtiError (*GetExtensionFunctions)(jvmtiEnv *, jint *, jvmtiExtensionFunctionInfo **);
     *     jvmtiError (*GetExtensionEvents)(jvmtiEnv *, jint *, jvmtiExtensionEventInfo **);
     *     jvmtiError (*SetExtensionEventCallback)(jvmtiEnv *, jint, jvmtiExtensionEvent);
     *     jvmtiError (*DisposeEnvironment)(jvmtiEnv *);
     *     jvmtiError (*GetErrorName)(jvmtiEnv *, jvmtiError, char **);
     *     jvmtiError (*GetJLocationFormat)(jvmtiEnv *, jvmtiJlocationFormat *);
     *     jvmtiError (*GetSystemProperties)(jvmtiEnv *, jint *, char ***);
     *     jvmtiError (*GetSystemProperty)(jvmtiEnv *, const char *, char **);
     *     jvmtiError (*SetSystemProperty)(jvmtiEnv *, const char *, const char *);
     *     jvmtiError (*GetPhase)(jvmtiEnv *, jvmtiPhase *);
     *     jvmtiError (*GetCurrentThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
     *     jvmtiError (*GetCurrentThreadCpuTime)(jvmtiEnv *, jlong *);
     *     jvmtiError (*GetThreadCpuTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
     *     jvmtiError (*GetThreadCpuTime)(jvmtiEnv *, jthread, jlong *);
     *     jvmtiError (*GetTimerInfo)(jvmtiEnv *, jvmtiTimerInfo *);
     *     jvmtiError (*GetTime)(jvmtiEnv *, jlong *);
     *     jvmtiError (*GetPotentialCapabilities)(jvmtiEnv *, jvmtiCapabilities *);
     *     void *reserved141;
     *     jvmtiError (*AddCapabilities)(jvmtiEnv *, const jvmtiCapabilities *);
     *     jvmtiError (*RelinquishCapabilities)(jvmtiEnv *, const jvmtiCapabilities *);
     *     jvmtiError (*GetAvailableProcessors)(jvmtiEnv *, jint *);
     *     jvmtiError (*GetClassVersionNumbers)(jvmtiEnv *, jclass, jint *, jint *);
     *     jvmtiError (*GetConstantPool)(jvmtiEnv *, jclass, jint *, jint *, unsigned char **);
     *     jvmtiError (*GetEnvironmentLocalStorage)(jvmtiEnv *, void **);
     *     jvmtiError (*SetEnvironmentLocalStorage)(jvmtiEnv *, const void *);
     *     jvmtiError (*AddToBootstrapClassLoaderSearch)(jvmtiEnv *, const char *);
     *     jvmtiError (*SetVerboseFlag)(jvmtiEnv *, jvmtiVerboseFlag, jboolean);
     *     jvmtiError (*AddToSystemClassLoaderSearch)(jvmtiEnv *, const char *);
     *     jvmtiError (*RetransformClasses)(jvmtiEnv *, jint, const jclass *);
     *     jvmtiError (*GetOwnedMonitorStackDepthInfo)(jvmtiEnv *, jthread, jint *, jvmtiMonitorStackDepthInfo **);
     *     jvmtiError (*GetObjectSize)(jvmtiEnv *, jobject, jlong *);
     *     jvmtiError (*GetLocalInstance)(jvmtiEnv *, jthread, jint, jobject *);
     *     jvmtiError (*SetHeapSamplingInterval)(jvmtiEnv *, jint);
     * } *jvmtiEnv
     * }
     */
    public static final AddressLayout jvmtiEnv = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jthread
     * }
     */
    public static final AddressLayout jthread = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jobject jthreadGroup
     * }
     */
    public static final AddressLayout jthreadGroup = jvmti_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef jlong jlocation
     * }
     */
    public static final OfLong jlocation = jvmti_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _jrawMonitorID *jrawMonitorID
     * }
     */
    public static final AddressLayout jrawMonitorID = jvmti_h.C_POINTER;
    private static final int JVMTI_THREAD_STATE_ALIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_ALIVE = 1
     * }
     */
    public static int JVMTI_THREAD_STATE_ALIVE() {
        return JVMTI_THREAD_STATE_ALIVE;
    }
    private static final int JVMTI_THREAD_STATE_TERMINATED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_TERMINATED = 2
     * }
     */
    public static int JVMTI_THREAD_STATE_TERMINATED() {
        return JVMTI_THREAD_STATE_TERMINATED;
    }
    private static final int JVMTI_THREAD_STATE_RUNNABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_RUNNABLE = 4
     * }
     */
    public static int JVMTI_THREAD_STATE_RUNNABLE() {
        return JVMTI_THREAD_STATE_RUNNABLE;
    }
    private static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 1024
     * }
     */
    public static int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER() {
        return JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;
    }
    private static final int JVMTI_THREAD_STATE_WAITING = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_WAITING = 128
     * }
     */
    public static int JVMTI_THREAD_STATE_WAITING() {
        return JVMTI_THREAD_STATE_WAITING;
    }
    private static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 16
     * }
     */
    public static int JVMTI_THREAD_STATE_WAITING_INDEFINITELY() {
        return JVMTI_THREAD_STATE_WAITING_INDEFINITELY;
    }
    private static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 32
     * }
     */
    public static int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT() {
        return JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT;
    }
    private static final int JVMTI_THREAD_STATE_SLEEPING = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_SLEEPING = 64
     * }
     */
    public static int JVMTI_THREAD_STATE_SLEEPING() {
        return JVMTI_THREAD_STATE_SLEEPING;
    }
    private static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 256
     * }
     */
    public static int JVMTI_THREAD_STATE_IN_OBJECT_WAIT() {
        return JVMTI_THREAD_STATE_IN_OBJECT_WAIT;
    }
    private static final int JVMTI_THREAD_STATE_PARKED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_PARKED = 512
     * }
     */
    public static int JVMTI_THREAD_STATE_PARKED() {
        return JVMTI_THREAD_STATE_PARKED;
    }
    private static final int JVMTI_THREAD_STATE_SUSPENDED = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_SUSPENDED = 1048576
     * }
     */
    public static int JVMTI_THREAD_STATE_SUSPENDED() {
        return JVMTI_THREAD_STATE_SUSPENDED;
    }
    private static final int JVMTI_THREAD_STATE_INTERRUPTED = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_INTERRUPTED = 2097152
     * }
     */
    public static int JVMTI_THREAD_STATE_INTERRUPTED() {
        return JVMTI_THREAD_STATE_INTERRUPTED;
    }
    private static final int JVMTI_THREAD_STATE_IN_NATIVE = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_IN_NATIVE = 4194304
     * }
     */
    public static int JVMTI_THREAD_STATE_IN_NATIVE() {
        return JVMTI_THREAD_STATE_IN_NATIVE;
    }
    private static final int JVMTI_THREAD_STATE_VENDOR_1 = (int)268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_VENDOR_1 = 268435456
     * }
     */
    public static int JVMTI_THREAD_STATE_VENDOR_1() {
        return JVMTI_THREAD_STATE_VENDOR_1;
    }
    private static final int JVMTI_THREAD_STATE_VENDOR_2 = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_VENDOR_2 = 536870912
     * }
     */
    public static int JVMTI_THREAD_STATE_VENDOR_2() {
        return JVMTI_THREAD_STATE_VENDOR_2;
    }
    private static final int JVMTI_THREAD_STATE_VENDOR_3 = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_STATE_VENDOR_3 = 1073741824
     * }
     */
    public static int JVMTI_THREAD_STATE_VENDOR_3() {
        return JVMTI_THREAD_STATE_VENDOR_3;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_MASK = (int)1207L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_MASK = 1207
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_MASK() {
        return JVMTI_JAVA_LANG_THREAD_STATE_MASK;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_NEW = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_NEW = 0
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_NEW() {
        return JVMTI_JAVA_LANG_THREAD_STATE_NEW;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = 2
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED() {
        return JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = 5
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE() {
        return JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = (int)1025L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = 1025
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED() {
        return JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_WAITING = (int)145L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_WAITING = 145
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_WAITING() {
        return JVMTI_JAVA_LANG_THREAD_STATE_WAITING;
    }
    private static final int JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = (int)161L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = 161
     * }
     */
    public static int JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING() {
        return JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING;
    }
    private static final int JVMTI_THREAD_MIN_PRIORITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_MIN_PRIORITY = 1
     * }
     */
    public static int JVMTI_THREAD_MIN_PRIORITY() {
        return JVMTI_THREAD_MIN_PRIORITY;
    }
    private static final int JVMTI_THREAD_NORM_PRIORITY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_NORM_PRIORITY = 5
     * }
     */
    public static int JVMTI_THREAD_NORM_PRIORITY() {
        return JVMTI_THREAD_NORM_PRIORITY;
    }
    private static final int JVMTI_THREAD_MAX_PRIORITY = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_THREAD_MAX_PRIORITY = 10
     * }
     */
    public static int JVMTI_THREAD_MAX_PRIORITY() {
        return JVMTI_THREAD_MAX_PRIORITY;
    }
    private static final int JVMTI_HEAP_FILTER_TAGGED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_FILTER_TAGGED = 4
     * }
     */
    public static int JVMTI_HEAP_FILTER_TAGGED() {
        return JVMTI_HEAP_FILTER_TAGGED;
    }
    private static final int JVMTI_HEAP_FILTER_UNTAGGED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_FILTER_UNTAGGED = 8
     * }
     */
    public static int JVMTI_HEAP_FILTER_UNTAGGED() {
        return JVMTI_HEAP_FILTER_UNTAGGED;
    }
    private static final int JVMTI_HEAP_FILTER_CLASS_TAGGED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_FILTER_CLASS_TAGGED = 16
     * }
     */
    public static int JVMTI_HEAP_FILTER_CLASS_TAGGED() {
        return JVMTI_HEAP_FILTER_CLASS_TAGGED;
    }
    private static final int JVMTI_HEAP_FILTER_CLASS_UNTAGGED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_FILTER_CLASS_UNTAGGED = 32
     * }
     */
    public static int JVMTI_HEAP_FILTER_CLASS_UNTAGGED() {
        return JVMTI_HEAP_FILTER_CLASS_UNTAGGED;
    }
    private static final int JVMTI_VISIT_OBJECTS = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VISIT_OBJECTS = 256
     * }
     */
    public static int JVMTI_VISIT_OBJECTS() {
        return JVMTI_VISIT_OBJECTS;
    }
    private static final int JVMTI_VISIT_ABORT = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VISIT_ABORT = 32768
     * }
     */
    public static int JVMTI_VISIT_ABORT() {
        return JVMTI_VISIT_ABORT;
    }
    private static final int JVMTI_HEAP_REFERENCE_CLASS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_CLASS = 1
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_CLASS() {
        return JVMTI_HEAP_REFERENCE_CLASS;
    }
    private static final int JVMTI_HEAP_REFERENCE_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_FIELD = 2
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_FIELD() {
        return JVMTI_HEAP_REFERENCE_FIELD;
    }
    private static final int JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT() {
        return JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT;
    }
    private static final int JVMTI_HEAP_REFERENCE_CLASS_LOADER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_CLASS_LOADER() {
        return JVMTI_HEAP_REFERENCE_CLASS_LOADER;
    }
    private static final int JVMTI_HEAP_REFERENCE_SIGNERS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_SIGNERS = 5
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_SIGNERS() {
        return JVMTI_HEAP_REFERENCE_SIGNERS;
    }
    private static final int JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN() {
        return JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN;
    }
    private static final int JVMTI_HEAP_REFERENCE_INTERFACE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_INTERFACE = 7
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_INTERFACE() {
        return JVMTI_HEAP_REFERENCE_INTERFACE;
    }
    private static final int JVMTI_HEAP_REFERENCE_STATIC_FIELD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_STATIC_FIELD() {
        return JVMTI_HEAP_REFERENCE_STATIC_FIELD;
    }
    private static final int JVMTI_HEAP_REFERENCE_CONSTANT_POOL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_CONSTANT_POOL() {
        return JVMTI_HEAP_REFERENCE_CONSTANT_POOL;
    }
    private static final int JVMTI_HEAP_REFERENCE_SUPERCLASS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_SUPERCLASS = 10
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_SUPERCLASS() {
        return JVMTI_HEAP_REFERENCE_SUPERCLASS;
    }
    private static final int JVMTI_HEAP_REFERENCE_JNI_GLOBAL = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_JNI_GLOBAL() {
        return JVMTI_HEAP_REFERENCE_JNI_GLOBAL;
    }
    private static final int JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_SYSTEM_CLASS() {
        return JVMTI_HEAP_REFERENCE_SYSTEM_CLASS;
    }
    private static final int JVMTI_HEAP_REFERENCE_MONITOR = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_MONITOR = 23
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_MONITOR() {
        return JVMTI_HEAP_REFERENCE_MONITOR;
    }
    private static final int JVMTI_HEAP_REFERENCE_STACK_LOCAL = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_STACK_LOCAL() {
        return JVMTI_HEAP_REFERENCE_STACK_LOCAL;
    }
    private static final int JVMTI_HEAP_REFERENCE_JNI_LOCAL = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_JNI_LOCAL() {
        return JVMTI_HEAP_REFERENCE_JNI_LOCAL;
    }
    private static final int JVMTI_HEAP_REFERENCE_THREAD = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_THREAD = 26
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_THREAD() {
        return JVMTI_HEAP_REFERENCE_THREAD;
    }
    private static final int JVMTI_HEAP_REFERENCE_OTHER = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_REFERENCE_OTHER = 27
     * }
     */
    public static int JVMTI_HEAP_REFERENCE_OTHER() {
        return JVMTI_HEAP_REFERENCE_OTHER;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_BOOLEAN = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_BOOLEAN() {
        return JVMTI_PRIMITIVE_TYPE_BOOLEAN;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_BYTE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_BYTE = 66
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_BYTE() {
        return JVMTI_PRIMITIVE_TYPE_BYTE;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_CHAR = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_CHAR = 67
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_CHAR() {
        return JVMTI_PRIMITIVE_TYPE_CHAR;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_SHORT = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_SHORT = 83
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_SHORT() {
        return JVMTI_PRIMITIVE_TYPE_SHORT;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_INT = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_INT = 73
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_INT() {
        return JVMTI_PRIMITIVE_TYPE_INT;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_LONG = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_LONG = 74
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_LONG() {
        return JVMTI_PRIMITIVE_TYPE_LONG;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_FLOAT = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_FLOAT = 70
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_FLOAT() {
        return JVMTI_PRIMITIVE_TYPE_FLOAT;
    }
    private static final int JVMTI_PRIMITIVE_TYPE_DOUBLE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
     * }
     */
    public static int JVMTI_PRIMITIVE_TYPE_DOUBLE() {
        return JVMTI_PRIMITIVE_TYPE_DOUBLE;
    }
    private static final int JVMTI_HEAP_OBJECT_TAGGED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_OBJECT_TAGGED = 1
     * }
     */
    public static int JVMTI_HEAP_OBJECT_TAGGED() {
        return JVMTI_HEAP_OBJECT_TAGGED;
    }
    private static final int JVMTI_HEAP_OBJECT_UNTAGGED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_OBJECT_UNTAGGED = 2
     * }
     */
    public static int JVMTI_HEAP_OBJECT_UNTAGGED() {
        return JVMTI_HEAP_OBJECT_UNTAGGED;
    }
    private static final int JVMTI_HEAP_OBJECT_EITHER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_OBJECT_EITHER = 3
     * }
     */
    public static int JVMTI_HEAP_OBJECT_EITHER() {
        return JVMTI_HEAP_OBJECT_EITHER;
    }
    private static final int JVMTI_HEAP_ROOT_JNI_GLOBAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_JNI_GLOBAL = 1
     * }
     */
    public static int JVMTI_HEAP_ROOT_JNI_GLOBAL() {
        return JVMTI_HEAP_ROOT_JNI_GLOBAL;
    }
    private static final int JVMTI_HEAP_ROOT_SYSTEM_CLASS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_SYSTEM_CLASS = 2
     * }
     */
    public static int JVMTI_HEAP_ROOT_SYSTEM_CLASS() {
        return JVMTI_HEAP_ROOT_SYSTEM_CLASS;
    }
    private static final int JVMTI_HEAP_ROOT_MONITOR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_MONITOR = 3
     * }
     */
    public static int JVMTI_HEAP_ROOT_MONITOR() {
        return JVMTI_HEAP_ROOT_MONITOR;
    }
    private static final int JVMTI_HEAP_ROOT_STACK_LOCAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_STACK_LOCAL = 4
     * }
     */
    public static int JVMTI_HEAP_ROOT_STACK_LOCAL() {
        return JVMTI_HEAP_ROOT_STACK_LOCAL;
    }
    private static final int JVMTI_HEAP_ROOT_JNI_LOCAL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_JNI_LOCAL = 5
     * }
     */
    public static int JVMTI_HEAP_ROOT_JNI_LOCAL() {
        return JVMTI_HEAP_ROOT_JNI_LOCAL;
    }
    private static final int JVMTI_HEAP_ROOT_THREAD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_THREAD = 6
     * }
     */
    public static int JVMTI_HEAP_ROOT_THREAD() {
        return JVMTI_HEAP_ROOT_THREAD;
    }
    private static final int JVMTI_HEAP_ROOT_OTHER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_HEAP_ROOT_OTHER = 7
     * }
     */
    public static int JVMTI_HEAP_ROOT_OTHER() {
        return JVMTI_HEAP_ROOT_OTHER;
    }
    private static final int JVMTI_REFERENCE_CLASS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_CLASS = 1
     * }
     */
    public static int JVMTI_REFERENCE_CLASS() {
        return JVMTI_REFERENCE_CLASS;
    }
    private static final int JVMTI_REFERENCE_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_FIELD = 2
     * }
     */
    public static int JVMTI_REFERENCE_FIELD() {
        return JVMTI_REFERENCE_FIELD;
    }
    private static final int JVMTI_REFERENCE_ARRAY_ELEMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_ARRAY_ELEMENT = 3
     * }
     */
    public static int JVMTI_REFERENCE_ARRAY_ELEMENT() {
        return JVMTI_REFERENCE_ARRAY_ELEMENT;
    }
    private static final int JVMTI_REFERENCE_CLASS_LOADER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_CLASS_LOADER = 4
     * }
     */
    public static int JVMTI_REFERENCE_CLASS_LOADER() {
        return JVMTI_REFERENCE_CLASS_LOADER;
    }
    private static final int JVMTI_REFERENCE_SIGNERS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_SIGNERS = 5
     * }
     */
    public static int JVMTI_REFERENCE_SIGNERS() {
        return JVMTI_REFERENCE_SIGNERS;
    }
    private static final int JVMTI_REFERENCE_PROTECTION_DOMAIN = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_PROTECTION_DOMAIN = 6
     * }
     */
    public static int JVMTI_REFERENCE_PROTECTION_DOMAIN() {
        return JVMTI_REFERENCE_PROTECTION_DOMAIN;
    }
    private static final int JVMTI_REFERENCE_INTERFACE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_INTERFACE = 7
     * }
     */
    public static int JVMTI_REFERENCE_INTERFACE() {
        return JVMTI_REFERENCE_INTERFACE;
    }
    private static final int JVMTI_REFERENCE_STATIC_FIELD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_STATIC_FIELD = 8
     * }
     */
    public static int JVMTI_REFERENCE_STATIC_FIELD() {
        return JVMTI_REFERENCE_STATIC_FIELD;
    }
    private static final int JVMTI_REFERENCE_CONSTANT_POOL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_REFERENCE_CONSTANT_POOL = 9
     * }
     */
    public static int JVMTI_REFERENCE_CONSTANT_POOL() {
        return JVMTI_REFERENCE_CONSTANT_POOL;
    }
    private static final int JVMTI_ITERATION_CONTINUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ITERATION_CONTINUE = 1
     * }
     */
    public static int JVMTI_ITERATION_CONTINUE() {
        return JVMTI_ITERATION_CONTINUE;
    }
    private static final int JVMTI_ITERATION_IGNORE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ITERATION_IGNORE = 2
     * }
     */
    public static int JVMTI_ITERATION_IGNORE() {
        return JVMTI_ITERATION_IGNORE;
    }
    private static final int JVMTI_ITERATION_ABORT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ITERATION_ABORT = 0
     * }
     */
    public static int JVMTI_ITERATION_ABORT() {
        return JVMTI_ITERATION_ABORT;
    }
    private static final int JVMTI_CLASS_STATUS_VERIFIED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_VERIFIED = 1
     * }
     */
    public static int JVMTI_CLASS_STATUS_VERIFIED() {
        return JVMTI_CLASS_STATUS_VERIFIED;
    }
    private static final int JVMTI_CLASS_STATUS_PREPARED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_PREPARED = 2
     * }
     */
    public static int JVMTI_CLASS_STATUS_PREPARED() {
        return JVMTI_CLASS_STATUS_PREPARED;
    }
    private static final int JVMTI_CLASS_STATUS_INITIALIZED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_INITIALIZED = 4
     * }
     */
    public static int JVMTI_CLASS_STATUS_INITIALIZED() {
        return JVMTI_CLASS_STATUS_INITIALIZED;
    }
    private static final int JVMTI_CLASS_STATUS_ERROR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_ERROR = 8
     * }
     */
    public static int JVMTI_CLASS_STATUS_ERROR() {
        return JVMTI_CLASS_STATUS_ERROR;
    }
    private static final int JVMTI_CLASS_STATUS_ARRAY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_ARRAY = 16
     * }
     */
    public static int JVMTI_CLASS_STATUS_ARRAY() {
        return JVMTI_CLASS_STATUS_ARRAY;
    }
    private static final int JVMTI_CLASS_STATUS_PRIMITIVE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_CLASS_STATUS_PRIMITIVE = 32
     * }
     */
    public static int JVMTI_CLASS_STATUS_PRIMITIVE() {
        return JVMTI_CLASS_STATUS_PRIMITIVE;
    }
    private static final int JVMTI_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ENABLE = 1
     * }
     */
    public static int JVMTI_ENABLE() {
        return JVMTI_ENABLE;
    }
    private static final int JVMTI_DISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_DISABLE = 0
     * }
     */
    public static int JVMTI_DISABLE() {
        return JVMTI_DISABLE;
    }
    private static final int JVMTI_TYPE_JBYTE = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JBYTE = 101
     * }
     */
    public static int JVMTI_TYPE_JBYTE() {
        return JVMTI_TYPE_JBYTE;
    }
    private static final int JVMTI_TYPE_JCHAR = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JCHAR = 102
     * }
     */
    public static int JVMTI_TYPE_JCHAR() {
        return JVMTI_TYPE_JCHAR;
    }
    private static final int JVMTI_TYPE_JSHORT = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JSHORT = 103
     * }
     */
    public static int JVMTI_TYPE_JSHORT() {
        return JVMTI_TYPE_JSHORT;
    }
    private static final int JVMTI_TYPE_JINT = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JINT = 104
     * }
     */
    public static int JVMTI_TYPE_JINT() {
        return JVMTI_TYPE_JINT;
    }
    private static final int JVMTI_TYPE_JLONG = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JLONG = 105
     * }
     */
    public static int JVMTI_TYPE_JLONG() {
        return JVMTI_TYPE_JLONG;
    }
    private static final int JVMTI_TYPE_JFLOAT = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JFLOAT = 106
     * }
     */
    public static int JVMTI_TYPE_JFLOAT() {
        return JVMTI_TYPE_JFLOAT;
    }
    private static final int JVMTI_TYPE_JDOUBLE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JDOUBLE = 107
     * }
     */
    public static int JVMTI_TYPE_JDOUBLE() {
        return JVMTI_TYPE_JDOUBLE;
    }
    private static final int JVMTI_TYPE_JBOOLEAN = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JBOOLEAN = 108
     * }
     */
    public static int JVMTI_TYPE_JBOOLEAN() {
        return JVMTI_TYPE_JBOOLEAN;
    }
    private static final int JVMTI_TYPE_JOBJECT = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JOBJECT = 109
     * }
     */
    public static int JVMTI_TYPE_JOBJECT() {
        return JVMTI_TYPE_JOBJECT;
    }
    private static final int JVMTI_TYPE_JTHREAD = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JTHREAD = 110
     * }
     */
    public static int JVMTI_TYPE_JTHREAD() {
        return JVMTI_TYPE_JTHREAD;
    }
    private static final int JVMTI_TYPE_JCLASS = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JCLASS = 111
     * }
     */
    public static int JVMTI_TYPE_JCLASS() {
        return JVMTI_TYPE_JCLASS;
    }
    private static final int JVMTI_TYPE_JVALUE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JVALUE = 112
     * }
     */
    public static int JVMTI_TYPE_JVALUE() {
        return JVMTI_TYPE_JVALUE;
    }
    private static final int JVMTI_TYPE_JFIELDID = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JFIELDID = 113
     * }
     */
    public static int JVMTI_TYPE_JFIELDID() {
        return JVMTI_TYPE_JFIELDID;
    }
    private static final int JVMTI_TYPE_JMETHODID = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JMETHODID = 114
     * }
     */
    public static int JVMTI_TYPE_JMETHODID() {
        return JVMTI_TYPE_JMETHODID;
    }
    private static final int JVMTI_TYPE_CCHAR = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_CCHAR = 115
     * }
     */
    public static int JVMTI_TYPE_CCHAR() {
        return JVMTI_TYPE_CCHAR;
    }
    private static final int JVMTI_TYPE_CVOID = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_CVOID = 116
     * }
     */
    public static int JVMTI_TYPE_CVOID() {
        return JVMTI_TYPE_CVOID;
    }
    private static final int JVMTI_TYPE_JNIENV = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TYPE_JNIENV = 117
     * }
     */
    public static int JVMTI_TYPE_JNIENV() {
        return JVMTI_TYPE_JNIENV;
    }
    private static final int JVMTI_KIND_IN = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_IN = 91
     * }
     */
    public static int JVMTI_KIND_IN() {
        return JVMTI_KIND_IN;
    }
    private static final int JVMTI_KIND_IN_PTR = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_IN_PTR = 92
     * }
     */
    public static int JVMTI_KIND_IN_PTR() {
        return JVMTI_KIND_IN_PTR;
    }
    private static final int JVMTI_KIND_IN_BUF = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_IN_BUF = 93
     * }
     */
    public static int JVMTI_KIND_IN_BUF() {
        return JVMTI_KIND_IN_BUF;
    }
    private static final int JVMTI_KIND_ALLOC_BUF = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_ALLOC_BUF = 94
     * }
     */
    public static int JVMTI_KIND_ALLOC_BUF() {
        return JVMTI_KIND_ALLOC_BUF;
    }
    private static final int JVMTI_KIND_ALLOC_ALLOC_BUF = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_ALLOC_ALLOC_BUF = 95
     * }
     */
    public static int JVMTI_KIND_ALLOC_ALLOC_BUF() {
        return JVMTI_KIND_ALLOC_ALLOC_BUF;
    }
    private static final int JVMTI_KIND_OUT = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_OUT = 96
     * }
     */
    public static int JVMTI_KIND_OUT() {
        return JVMTI_KIND_OUT;
    }
    private static final int JVMTI_KIND_OUT_BUF = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_KIND_OUT_BUF = 97
     * }
     */
    public static int JVMTI_KIND_OUT_BUF() {
        return JVMTI_KIND_OUT_BUF;
    }
    private static final int JVMTI_TIMER_USER_CPU = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TIMER_USER_CPU = 30
     * }
     */
    public static int JVMTI_TIMER_USER_CPU() {
        return JVMTI_TIMER_USER_CPU;
    }
    private static final int JVMTI_TIMER_TOTAL_CPU = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TIMER_TOTAL_CPU = 31
     * }
     */
    public static int JVMTI_TIMER_TOTAL_CPU() {
        return JVMTI_TIMER_TOTAL_CPU;
    }
    private static final int JVMTI_TIMER_ELAPSED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_TIMER_ELAPSED = 32
     * }
     */
    public static int JVMTI_TIMER_ELAPSED() {
        return JVMTI_TIMER_ELAPSED;
    }
    private static final int JVMTI_PHASE_ONLOAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PHASE_ONLOAD = 1
     * }
     */
    public static int JVMTI_PHASE_ONLOAD() {
        return JVMTI_PHASE_ONLOAD;
    }
    private static final int JVMTI_PHASE_PRIMORDIAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PHASE_PRIMORDIAL = 2
     * }
     */
    public static int JVMTI_PHASE_PRIMORDIAL() {
        return JVMTI_PHASE_PRIMORDIAL;
    }
    private static final int JVMTI_PHASE_START = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PHASE_START = 6
     * }
     */
    public static int JVMTI_PHASE_START() {
        return JVMTI_PHASE_START;
    }
    private static final int JVMTI_PHASE_LIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PHASE_LIVE = 4
     * }
     */
    public static int JVMTI_PHASE_LIVE() {
        return JVMTI_PHASE_LIVE;
    }
    private static final int JVMTI_PHASE_DEAD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_PHASE_DEAD = 8
     * }
     */
    public static int JVMTI_PHASE_DEAD() {
        return JVMTI_PHASE_DEAD;
    }
    private static final int JVMTI_VERSION_INTERFACE_JNI = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_INTERFACE_JNI = 0
     * }
     */
    public static int JVMTI_VERSION_INTERFACE_JNI() {
        return JVMTI_VERSION_INTERFACE_JNI;
    }
    private static final int JVMTI_VERSION_INTERFACE_JVMTI = (int)805306368L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_INTERFACE_JVMTI = 805306368
     * }
     */
    public static int JVMTI_VERSION_INTERFACE_JVMTI() {
        return JVMTI_VERSION_INTERFACE_JVMTI;
    }
    private static final int JVMTI_VERSION_MASK_INTERFACE_TYPE = (int)1879048192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_MASK_INTERFACE_TYPE = 1879048192
     * }
     */
    public static int JVMTI_VERSION_MASK_INTERFACE_TYPE() {
        return JVMTI_VERSION_MASK_INTERFACE_TYPE;
    }
    private static final int JVMTI_VERSION_MASK_MAJOR = (int)268369920L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_MASK_MAJOR = 268369920
     * }
     */
    public static int JVMTI_VERSION_MASK_MAJOR() {
        return JVMTI_VERSION_MASK_MAJOR;
    }
    private static final int JVMTI_VERSION_MASK_MINOR = (int)65280L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_MASK_MINOR = 65280
     * }
     */
    public static int JVMTI_VERSION_MASK_MINOR() {
        return JVMTI_VERSION_MASK_MINOR;
    }
    private static final int JVMTI_VERSION_MASK_MICRO = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_MASK_MICRO = 255
     * }
     */
    public static int JVMTI_VERSION_MASK_MICRO() {
        return JVMTI_VERSION_MASK_MICRO;
    }
    private static final int JVMTI_VERSION_SHIFT_MAJOR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_SHIFT_MAJOR = 16
     * }
     */
    public static int JVMTI_VERSION_SHIFT_MAJOR() {
        return JVMTI_VERSION_SHIFT_MAJOR;
    }
    private static final int JVMTI_VERSION_SHIFT_MINOR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_SHIFT_MINOR = 8
     * }
     */
    public static int JVMTI_VERSION_SHIFT_MINOR() {
        return JVMTI_VERSION_SHIFT_MINOR;
    }
    private static final int JVMTI_VERSION_SHIFT_MICRO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERSION_SHIFT_MICRO = 0
     * }
     */
    public static int JVMTI_VERSION_SHIFT_MICRO() {
        return JVMTI_VERSION_SHIFT_MICRO;
    }
    private static final int JVMTI_VERBOSE_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERBOSE_OTHER = 0
     * }
     */
    public static int JVMTI_VERBOSE_OTHER() {
        return JVMTI_VERBOSE_OTHER;
    }
    private static final int JVMTI_VERBOSE_GC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERBOSE_GC = 1
     * }
     */
    public static int JVMTI_VERBOSE_GC() {
        return JVMTI_VERBOSE_GC;
    }
    private static final int JVMTI_VERBOSE_CLASS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERBOSE_CLASS = 2
     * }
     */
    public static int JVMTI_VERBOSE_CLASS() {
        return JVMTI_VERBOSE_CLASS;
    }
    private static final int JVMTI_VERBOSE_JNI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_VERBOSE_JNI = 4
     * }
     */
    public static int JVMTI_VERBOSE_JNI() {
        return JVMTI_VERBOSE_JNI;
    }
    private static final int JVMTI_JLOCATION_JVMBCI = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JLOCATION_JVMBCI = 1
     * }
     */
    public static int JVMTI_JLOCATION_JVMBCI() {
        return JVMTI_JLOCATION_JVMBCI;
    }
    private static final int JVMTI_JLOCATION_MACHINEPC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JLOCATION_MACHINEPC = 2
     * }
     */
    public static int JVMTI_JLOCATION_MACHINEPC() {
        return JVMTI_JLOCATION_MACHINEPC;
    }
    private static final int JVMTI_JLOCATION_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_JLOCATION_OTHER = 0
     * }
     */
    public static int JVMTI_JLOCATION_OTHER() {
        return JVMTI_JLOCATION_OTHER;
    }
    private static final int JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = 1
     * }
     */
    public static int JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR() {
        return JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR;
    }
    private static final int JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = 2
     * }
     */
    public static int JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP() {
        return JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP;
    }
    private static final int JVMTI_RESOURCE_EXHAUSTED_THREADS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_RESOURCE_EXHAUSTED_THREADS = 4
     * }
     */
    public static int JVMTI_RESOURCE_EXHAUSTED_THREADS() {
        return JVMTI_RESOURCE_EXHAUSTED_THREADS;
    }
    private static final int JVMTI_ERROR_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NONE = 0
     * }
     */
    public static int JVMTI_ERROR_NONE() {
        return JVMTI_ERROR_NONE;
    }
    private static final int JVMTI_ERROR_INVALID_THREAD = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_THREAD = 10
     * }
     */
    public static int JVMTI_ERROR_INVALID_THREAD() {
        return JVMTI_ERROR_INVALID_THREAD;
    }
    private static final int JVMTI_ERROR_INVALID_THREAD_GROUP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_THREAD_GROUP = 11
     * }
     */
    public static int JVMTI_ERROR_INVALID_THREAD_GROUP() {
        return JVMTI_ERROR_INVALID_THREAD_GROUP;
    }
    private static final int JVMTI_ERROR_INVALID_PRIORITY = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_PRIORITY = 12
     * }
     */
    public static int JVMTI_ERROR_INVALID_PRIORITY() {
        return JVMTI_ERROR_INVALID_PRIORITY;
    }
    private static final int JVMTI_ERROR_THREAD_NOT_SUSPENDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13
     * }
     */
    public static int JVMTI_ERROR_THREAD_NOT_SUSPENDED() {
        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
    }
    private static final int JVMTI_ERROR_THREAD_SUSPENDED = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_THREAD_SUSPENDED = 14
     * }
     */
    public static int JVMTI_ERROR_THREAD_SUSPENDED() {
        return JVMTI_ERROR_THREAD_SUSPENDED;
    }
    private static final int JVMTI_ERROR_THREAD_NOT_ALIVE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_THREAD_NOT_ALIVE = 15
     * }
     */
    public static int JVMTI_ERROR_THREAD_NOT_ALIVE() {
        return JVMTI_ERROR_THREAD_NOT_ALIVE;
    }
    private static final int JVMTI_ERROR_INVALID_OBJECT = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_OBJECT = 20
     * }
     */
    public static int JVMTI_ERROR_INVALID_OBJECT() {
        return JVMTI_ERROR_INVALID_OBJECT;
    }
    private static final int JVMTI_ERROR_INVALID_CLASS = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_CLASS = 21
     * }
     */
    public static int JVMTI_ERROR_INVALID_CLASS() {
        return JVMTI_ERROR_INVALID_CLASS;
    }
    private static final int JVMTI_ERROR_CLASS_NOT_PREPARED = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_CLASS_NOT_PREPARED = 22
     * }
     */
    public static int JVMTI_ERROR_CLASS_NOT_PREPARED() {
        return JVMTI_ERROR_CLASS_NOT_PREPARED;
    }
    private static final int JVMTI_ERROR_INVALID_METHODID = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_METHODID = 23
     * }
     */
    public static int JVMTI_ERROR_INVALID_METHODID() {
        return JVMTI_ERROR_INVALID_METHODID;
    }
    private static final int JVMTI_ERROR_INVALID_LOCATION = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_LOCATION = 24
     * }
     */
    public static int JVMTI_ERROR_INVALID_LOCATION() {
        return JVMTI_ERROR_INVALID_LOCATION;
    }
    private static final int JVMTI_ERROR_INVALID_FIELDID = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_FIELDID = 25
     * }
     */
    public static int JVMTI_ERROR_INVALID_FIELDID() {
        return JVMTI_ERROR_INVALID_FIELDID;
    }
    private static final int JVMTI_ERROR_INVALID_MODULE = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_MODULE = 26
     * }
     */
    public static int JVMTI_ERROR_INVALID_MODULE() {
        return JVMTI_ERROR_INVALID_MODULE;
    }
    private static final int JVMTI_ERROR_NO_MORE_FRAMES = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NO_MORE_FRAMES = 31
     * }
     */
    public static int JVMTI_ERROR_NO_MORE_FRAMES() {
        return JVMTI_ERROR_NO_MORE_FRAMES;
    }
    private static final int JVMTI_ERROR_OPAQUE_FRAME = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_OPAQUE_FRAME = 32
     * }
     */
    public static int JVMTI_ERROR_OPAQUE_FRAME() {
        return JVMTI_ERROR_OPAQUE_FRAME;
    }
    private static final int JVMTI_ERROR_TYPE_MISMATCH = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_TYPE_MISMATCH = 34
     * }
     */
    public static int JVMTI_ERROR_TYPE_MISMATCH() {
        return JVMTI_ERROR_TYPE_MISMATCH;
    }
    private static final int JVMTI_ERROR_INVALID_SLOT = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_SLOT = 35
     * }
     */
    public static int JVMTI_ERROR_INVALID_SLOT() {
        return JVMTI_ERROR_INVALID_SLOT;
    }
    private static final int JVMTI_ERROR_DUPLICATE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_DUPLICATE = 40
     * }
     */
    public static int JVMTI_ERROR_DUPLICATE() {
        return JVMTI_ERROR_DUPLICATE;
    }
    private static final int JVMTI_ERROR_NOT_FOUND = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NOT_FOUND = 41
     * }
     */
    public static int JVMTI_ERROR_NOT_FOUND() {
        return JVMTI_ERROR_NOT_FOUND;
    }
    private static final int JVMTI_ERROR_INVALID_MONITOR = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_MONITOR = 50
     * }
     */
    public static int JVMTI_ERROR_INVALID_MONITOR() {
        return JVMTI_ERROR_INVALID_MONITOR;
    }
    private static final int JVMTI_ERROR_NOT_MONITOR_OWNER = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NOT_MONITOR_OWNER = 51
     * }
     */
    public static int JVMTI_ERROR_NOT_MONITOR_OWNER() {
        return JVMTI_ERROR_NOT_MONITOR_OWNER;
    }
    private static final int JVMTI_ERROR_INTERRUPT = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INTERRUPT = 52
     * }
     */
    public static int JVMTI_ERROR_INTERRUPT() {
        return JVMTI_ERROR_INTERRUPT;
    }
    private static final int JVMTI_ERROR_INVALID_CLASS_FORMAT = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_CLASS_FORMAT = 60
     * }
     */
    public static int JVMTI_ERROR_INVALID_CLASS_FORMAT() {
        return JVMTI_ERROR_INVALID_CLASS_FORMAT;
    }
    private static final int JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61
     * }
     */
    public static int JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION() {
        return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
    }
    private static final int JVMTI_ERROR_FAILS_VERIFICATION = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_FAILS_VERIFICATION = 62
     * }
     */
    public static int JVMTI_ERROR_FAILS_VERIFICATION() {
        return JVMTI_ERROR_FAILS_VERIFICATION;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
    }
    private static final int JVMTI_ERROR_INVALID_TYPESTATE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_TYPESTATE = 65
     * }
     */
    public static int JVMTI_ERROR_INVALID_TYPESTATE() {
        return JVMTI_ERROR_INVALID_TYPESTATE;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_VERSION = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_VERSION = 68
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_VERSION() {
        return JVMTI_ERROR_UNSUPPORTED_VERSION;
    }
    private static final int JVMTI_ERROR_NAMES_DONT_MATCH = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NAMES_DONT_MATCH = 69
     * }
     */
    public static int JVMTI_ERROR_NAMES_DONT_MATCH() {
        return JVMTI_ERROR_NAMES_DONT_MATCH;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED = 72
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED() {
        return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
    }
    private static final int JVMTI_ERROR_UNSUPPORTED_OPERATION = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNSUPPORTED_OPERATION = 73
     * }
     */
    public static int JVMTI_ERROR_UNSUPPORTED_OPERATION() {
        return JVMTI_ERROR_UNSUPPORTED_OPERATION;
    }
    private static final int JVMTI_ERROR_UNMODIFIABLE_CLASS = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNMODIFIABLE_CLASS = 79
     * }
     */
    public static int JVMTI_ERROR_UNMODIFIABLE_CLASS() {
        return JVMTI_ERROR_UNMODIFIABLE_CLASS;
    }
    private static final int JVMTI_ERROR_UNMODIFIABLE_MODULE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNMODIFIABLE_MODULE = 80
     * }
     */
    public static int JVMTI_ERROR_UNMODIFIABLE_MODULE() {
        return JVMTI_ERROR_UNMODIFIABLE_MODULE;
    }
    private static final int JVMTI_ERROR_NOT_AVAILABLE = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NOT_AVAILABLE = 98
     * }
     */
    public static int JVMTI_ERROR_NOT_AVAILABLE() {
        return JVMTI_ERROR_NOT_AVAILABLE;
    }
    private static final int JVMTI_ERROR_MUST_POSSESS_CAPABILITY = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99
     * }
     */
    public static int JVMTI_ERROR_MUST_POSSESS_CAPABILITY() {
        return JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
    }
    private static final int JVMTI_ERROR_NULL_POINTER = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NULL_POINTER = 100
     * }
     */
    public static int JVMTI_ERROR_NULL_POINTER() {
        return JVMTI_ERROR_NULL_POINTER;
    }
    private static final int JVMTI_ERROR_ABSENT_INFORMATION = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_ABSENT_INFORMATION = 101
     * }
     */
    public static int JVMTI_ERROR_ABSENT_INFORMATION() {
        return JVMTI_ERROR_ABSENT_INFORMATION;
    }
    private static final int JVMTI_ERROR_INVALID_EVENT_TYPE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_EVENT_TYPE = 102
     * }
     */
    public static int JVMTI_ERROR_INVALID_EVENT_TYPE() {
        return JVMTI_ERROR_INVALID_EVENT_TYPE;
    }
    private static final int JVMTI_ERROR_ILLEGAL_ARGUMENT = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_ILLEGAL_ARGUMENT = 103
     * }
     */
    public static int JVMTI_ERROR_ILLEGAL_ARGUMENT() {
        return JVMTI_ERROR_ILLEGAL_ARGUMENT;
    }
    private static final int JVMTI_ERROR_NATIVE_METHOD = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_NATIVE_METHOD = 104
     * }
     */
    public static int JVMTI_ERROR_NATIVE_METHOD() {
        return JVMTI_ERROR_NATIVE_METHOD;
    }
    private static final int JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106
     * }
     */
    public static int JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED() {
        return JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED;
    }
    private static final int JVMTI_ERROR_OUT_OF_MEMORY = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_OUT_OF_MEMORY = 110
     * }
     */
    public static int JVMTI_ERROR_OUT_OF_MEMORY() {
        return JVMTI_ERROR_OUT_OF_MEMORY;
    }
    private static final int JVMTI_ERROR_ACCESS_DENIED = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_ACCESS_DENIED = 111
     * }
     */
    public static int JVMTI_ERROR_ACCESS_DENIED() {
        return JVMTI_ERROR_ACCESS_DENIED;
    }
    private static final int JVMTI_ERROR_WRONG_PHASE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_WRONG_PHASE = 112
     * }
     */
    public static int JVMTI_ERROR_WRONG_PHASE() {
        return JVMTI_ERROR_WRONG_PHASE;
    }
    private static final int JVMTI_ERROR_INTERNAL = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INTERNAL = 113
     * }
     */
    public static int JVMTI_ERROR_INTERNAL() {
        return JVMTI_ERROR_INTERNAL;
    }
    private static final int JVMTI_ERROR_UNATTACHED_THREAD = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_UNATTACHED_THREAD = 115
     * }
     */
    public static int JVMTI_ERROR_UNATTACHED_THREAD() {
        return JVMTI_ERROR_UNATTACHED_THREAD;
    }
    private static final int JVMTI_ERROR_INVALID_ENVIRONMENT = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_INVALID_ENVIRONMENT = 116
     * }
     */
    public static int JVMTI_ERROR_INVALID_ENVIRONMENT() {
        return JVMTI_ERROR_INVALID_ENVIRONMENT;
    }
    private static final int JVMTI_ERROR_MAX = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_ERROR_MAX = 116
     * }
     */
    public static int JVMTI_ERROR_MAX() {
        return JVMTI_ERROR_MAX;
    }
    private static final int JVMTI_MIN_EVENT_TYPE_VAL = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_MIN_EVENT_TYPE_VAL = 50
     * }
     */
    public static int JVMTI_MIN_EVENT_TYPE_VAL() {
        return JVMTI_MIN_EVENT_TYPE_VAL;
    }
    private static final int JVMTI_EVENT_VM_INIT = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VM_INIT = 50
     * }
     */
    public static int JVMTI_EVENT_VM_INIT() {
        return JVMTI_EVENT_VM_INIT;
    }
    private static final int JVMTI_EVENT_VM_DEATH = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VM_DEATH = 51
     * }
     */
    public static int JVMTI_EVENT_VM_DEATH() {
        return JVMTI_EVENT_VM_DEATH;
    }
    private static final int JVMTI_EVENT_THREAD_START = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_THREAD_START = 52
     * }
     */
    public static int JVMTI_EVENT_THREAD_START() {
        return JVMTI_EVENT_THREAD_START;
    }
    private static final int JVMTI_EVENT_THREAD_END = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_THREAD_END = 53
     * }
     */
    public static int JVMTI_EVENT_THREAD_END() {
        return JVMTI_EVENT_THREAD_END;
    }
    private static final int JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = 54
     * }
     */
    public static int JVMTI_EVENT_CLASS_FILE_LOAD_HOOK() {
        return JVMTI_EVENT_CLASS_FILE_LOAD_HOOK;
    }
    private static final int JVMTI_EVENT_CLASS_LOAD = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_CLASS_LOAD = 55
     * }
     */
    public static int JVMTI_EVENT_CLASS_LOAD() {
        return JVMTI_EVENT_CLASS_LOAD;
    }
    private static final int JVMTI_EVENT_CLASS_PREPARE = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_CLASS_PREPARE = 56
     * }
     */
    public static int JVMTI_EVENT_CLASS_PREPARE() {
        return JVMTI_EVENT_CLASS_PREPARE;
    }
    private static final int JVMTI_EVENT_VM_START = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VM_START = 57
     * }
     */
    public static int JVMTI_EVENT_VM_START() {
        return JVMTI_EVENT_VM_START;
    }
    private static final int JVMTI_EVENT_EXCEPTION = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_EXCEPTION = 58
     * }
     */
    public static int JVMTI_EVENT_EXCEPTION() {
        return JVMTI_EVENT_EXCEPTION;
    }
    private static final int JVMTI_EVENT_EXCEPTION_CATCH = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_EXCEPTION_CATCH = 59
     * }
     */
    public static int JVMTI_EVENT_EXCEPTION_CATCH() {
        return JVMTI_EVENT_EXCEPTION_CATCH;
    }
    private static final int JVMTI_EVENT_SINGLE_STEP = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_SINGLE_STEP = 60
     * }
     */
    public static int JVMTI_EVENT_SINGLE_STEP() {
        return JVMTI_EVENT_SINGLE_STEP;
    }
    private static final int JVMTI_EVENT_FRAME_POP = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_FRAME_POP = 61
     * }
     */
    public static int JVMTI_EVENT_FRAME_POP() {
        return JVMTI_EVENT_FRAME_POP;
    }
    private static final int JVMTI_EVENT_BREAKPOINT = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_BREAKPOINT = 62
     * }
     */
    public static int JVMTI_EVENT_BREAKPOINT() {
        return JVMTI_EVENT_BREAKPOINT;
    }
    private static final int JVMTI_EVENT_FIELD_ACCESS = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_FIELD_ACCESS = 63
     * }
     */
    public static int JVMTI_EVENT_FIELD_ACCESS() {
        return JVMTI_EVENT_FIELD_ACCESS;
    }
    private static final int JVMTI_EVENT_FIELD_MODIFICATION = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_FIELD_MODIFICATION = 64
     * }
     */
    public static int JVMTI_EVENT_FIELD_MODIFICATION() {
        return JVMTI_EVENT_FIELD_MODIFICATION;
    }
    private static final int JVMTI_EVENT_METHOD_ENTRY = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_METHOD_ENTRY = 65
     * }
     */
    public static int JVMTI_EVENT_METHOD_ENTRY() {
        return JVMTI_EVENT_METHOD_ENTRY;
    }
    private static final int JVMTI_EVENT_METHOD_EXIT = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_METHOD_EXIT = 66
     * }
     */
    public static int JVMTI_EVENT_METHOD_EXIT() {
        return JVMTI_EVENT_METHOD_EXIT;
    }
    private static final int JVMTI_EVENT_NATIVE_METHOD_BIND = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_NATIVE_METHOD_BIND = 67
     * }
     */
    public static int JVMTI_EVENT_NATIVE_METHOD_BIND() {
        return JVMTI_EVENT_NATIVE_METHOD_BIND;
    }
    private static final int JVMTI_EVENT_COMPILED_METHOD_LOAD = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_COMPILED_METHOD_LOAD = 68
     * }
     */
    public static int JVMTI_EVENT_COMPILED_METHOD_LOAD() {
        return JVMTI_EVENT_COMPILED_METHOD_LOAD;
    }
    private static final int JVMTI_EVENT_COMPILED_METHOD_UNLOAD = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_COMPILED_METHOD_UNLOAD = 69
     * }
     */
    public static int JVMTI_EVENT_COMPILED_METHOD_UNLOAD() {
        return JVMTI_EVENT_COMPILED_METHOD_UNLOAD;
    }
    private static final int JVMTI_EVENT_DYNAMIC_CODE_GENERATED = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_DYNAMIC_CODE_GENERATED = 70
     * }
     */
    public static int JVMTI_EVENT_DYNAMIC_CODE_GENERATED() {
        return JVMTI_EVENT_DYNAMIC_CODE_GENERATED;
    }
    private static final int JVMTI_EVENT_DATA_DUMP_REQUEST = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_DATA_DUMP_REQUEST = 71
     * }
     */
    public static int JVMTI_EVENT_DATA_DUMP_REQUEST() {
        return JVMTI_EVENT_DATA_DUMP_REQUEST;
    }
    private static final int JVMTI_EVENT_MONITOR_WAIT = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_MONITOR_WAIT = 73
     * }
     */
    public static int JVMTI_EVENT_MONITOR_WAIT() {
        return JVMTI_EVENT_MONITOR_WAIT;
    }
    private static final int JVMTI_EVENT_MONITOR_WAITED = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_MONITOR_WAITED = 74
     * }
     */
    public static int JVMTI_EVENT_MONITOR_WAITED() {
        return JVMTI_EVENT_MONITOR_WAITED;
    }
    private static final int JVMTI_EVENT_MONITOR_CONTENDED_ENTER = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_MONITOR_CONTENDED_ENTER = 75
     * }
     */
    public static int JVMTI_EVENT_MONITOR_CONTENDED_ENTER() {
        return JVMTI_EVENT_MONITOR_CONTENDED_ENTER;
    }
    private static final int JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = 76
     * }
     */
    public static int JVMTI_EVENT_MONITOR_CONTENDED_ENTERED() {
        return JVMTI_EVENT_MONITOR_CONTENDED_ENTERED;
    }
    private static final int JVMTI_EVENT_RESOURCE_EXHAUSTED = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_RESOURCE_EXHAUSTED = 80
     * }
     */
    public static int JVMTI_EVENT_RESOURCE_EXHAUSTED() {
        return JVMTI_EVENT_RESOURCE_EXHAUSTED;
    }
    private static final int JVMTI_EVENT_GARBAGE_COLLECTION_START = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_GARBAGE_COLLECTION_START = 81
     * }
     */
    public static int JVMTI_EVENT_GARBAGE_COLLECTION_START() {
        return JVMTI_EVENT_GARBAGE_COLLECTION_START;
    }
    private static final int JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = 82
     * }
     */
    public static int JVMTI_EVENT_GARBAGE_COLLECTION_FINISH() {
        return JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;
    }
    private static final int JVMTI_EVENT_OBJECT_FREE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_OBJECT_FREE = 83
     * }
     */
    public static int JVMTI_EVENT_OBJECT_FREE() {
        return JVMTI_EVENT_OBJECT_FREE;
    }
    private static final int JVMTI_EVENT_VM_OBJECT_ALLOC = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VM_OBJECT_ALLOC = 84
     * }
     */
    public static int JVMTI_EVENT_VM_OBJECT_ALLOC() {
        return JVMTI_EVENT_VM_OBJECT_ALLOC;
    }
    private static final int JVMTI_EVENT_SAMPLED_OBJECT_ALLOC = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_SAMPLED_OBJECT_ALLOC = 86
     * }
     */
    public static int JVMTI_EVENT_SAMPLED_OBJECT_ALLOC() {
        return JVMTI_EVENT_SAMPLED_OBJECT_ALLOC;
    }
    private static final int JVMTI_EVENT_VIRTUAL_THREAD_START = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VIRTUAL_THREAD_START = 87
     * }
     */
    public static int JVMTI_EVENT_VIRTUAL_THREAD_START() {
        return JVMTI_EVENT_VIRTUAL_THREAD_START;
    }
    private static final int JVMTI_EVENT_VIRTUAL_THREAD_END = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_EVENT_VIRTUAL_THREAD_END = 88
     * }
     */
    public static int JVMTI_EVENT_VIRTUAL_THREAD_END() {
        return JVMTI_EVENT_VIRTUAL_THREAD_END;
    }
    private static final int JVMTI_MAX_EVENT_TYPE_VAL = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.JVMTI_MAX_EVENT_TYPE_VAL = 88
     * }
     */
    public static int JVMTI_MAX_EVENT_TYPE_VAL() {
        return JVMTI_MAX_EVENT_TYPE_VAL;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final long __STDC_ISO_10646__ = 201103L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201103
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _IO_BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _IO_BUFSIZ 8192
     * }
     */
    public static int _IO_BUFSIZ() {
        return _IO_BUFSIZ;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    private static final int _IO_MAGIC = (int)4222418944L;
    /**
     * {@snippet lang=c :
     * #define _IO_MAGIC 4222418944
     * }
     */
    public static int _IO_MAGIC() {
        return _IO_MAGIC;
    }
    private static final int _OLD_STDIO_MAGIC = (int)4206624768L;
    /**
     * {@snippet lang=c :
     * #define _OLD_STDIO_MAGIC 4206624768
     * }
     */
    public static int _OLD_STDIO_MAGIC() {
        return _OLD_STDIO_MAGIC;
    }
    private static final int _IO_MAGIC_MASK = (int)4294901760L;
    /**
     * {@snippet lang=c :
     * #define _IO_MAGIC_MASK 4294901760
     * }
     */
    public static int _IO_MAGIC_MASK() {
        return _IO_MAGIC_MASK;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = jvmti_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int JNI_ERR = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define JNI_ERR -1
     * }
     */
    public static int JNI_ERR() {
        return JNI_ERR;
    }
    private static final int JNI_EDETACHED = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define JNI_EDETACHED -2
     * }
     */
    public static int JNI_EDETACHED() {
        return JNI_EDETACHED;
    }
    private static final int JNI_EVERSION = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define JNI_EVERSION -3
     * }
     */
    public static int JNI_EVERSION() {
        return JNI_EVERSION;
    }
    private static final int JNI_ENOMEM = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define JNI_ENOMEM -4
     * }
     */
    public static int JNI_ENOMEM() {
        return JNI_ENOMEM;
    }
    private static final int JNI_EEXIST = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define JNI_EEXIST -5
     * }
     */
    public static int JNI_EEXIST() {
        return JNI_EEXIST;
    }
    private static final int JNI_EINVAL = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define JNI_EINVAL -6
     * }
     */
    public static int JNI_EINVAL() {
        return JNI_EINVAL;
    }
}

